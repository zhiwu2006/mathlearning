怎么分步骤引导一个小学生去？比如先读题目，总结出直接条件，间接条件，然后看看题目要求什么，跟条件什么关系，需不需要多步计算等，请把我的思路扩展详细，请调用你的最大算力并结合你的知识库深入详细解析一下
小学生解题的分步骤引导法
你这套思路非常对：读题—提炼条件—明确问题—建立关系—设计步骤—计算与复核。下面我把它扩展成一套可落地的课堂流程、模板与话术，既能手把手带学生走一遍，也能逐步放手让他们独立完成。

教学目标与核心原则
目标聚焦: 让学生形成稳定的“读—想—画/列—算—查”的解题习惯，并能自检自纠。

核心原则:

结构化: 每一步都有固定动作与产出（如圈画、表格、示意图、等式）。

可视化: 用条形图、线段图、单位量表，把抽象关系变成“能看见”的关系。

元认知: 每步问自己“我在做什么？为什么？还缺什么？有没有别解？”

由扶到放: 先全引导，再半引导，最后独立完成并自评。

标准解题流程（可直接落地）
1. 读题与界定范围
第一读（整体感知）： 读出题目主语、场景、数量词。

动作: 用笔画出人物、物品、单位，圈出所有数字和单位。

第二读（提炼条件）： 把信息分为“直接条件”和“间接条件/隐含条件”。

直接条件定义: 题目中明确给出、无需推理即可使用的量或关系。

间接条件定义: 需要转换、推理、或与常识/定义结合才能用的量或关系（如“平均”“比…多”“合计”等）。

第三读（明确问题）： 用自己的话复述“求什么？单位是什么？是否唯一？”

2. 条件整理与信息结构化
条件清单（表格化）：

已知量: 列出每个量、单位、对象（谁的、什么的）。

关系式: 关系关键词与等式/不等式雏形（如“多/少、倍、平均、总和、差、比例、速度时间路程”）。

可视化表示：

条形/线段图: 一看就能看出“总—部分—部分”“倍数”“差值”。

单位量标注: 在图/表上标明单位，避免无单位运算。

3. 分析题目需求与关系匹配
任务拆解: 把“求什么”拆成一到多步的“中间目标”。

动作: 列“目标链”：

目标1 → 目标2 → 目标3 → 最终答案（每个目标旁写可能使用的条件）。

关系匹配: 用“所需→已有”的检核法判断是否需要引入中间量。

提问句: “要得到这个量，我缺什么？这些缺的能由哪些条件推出？”

4. 计算计划设计（而非直接算）
运算路线图: 决定先算哪一步、用什么公式或运算、为什么这样排。

估算与边界: 粗估结果区间，防止数量级错误。

单位核对: 每一步都标单位，确保加减乘除对“同类单位或可转换单位”进行。

5. 执行计算与格式规范
逐步计算: 每步只做一件事，写清“来处”和“去处”。

中间结果标注: 左侧写“步名”（如“求总数”“求单价”），右侧写算式与结果。

6. 复核与反思
三重检查:

条件对照: 每个条件是否被使用或合理解释？

单位与数量级: 单位是否正确、数量是否合理、估算是否匹配？

逆向验证或替代关系: 用反推或另一关系验证一次关键结果。

反思卡片: 本题结构类型、关键词、哪一步最易错、可迁移到哪类题。

常用工具与可视化
关键词—运算对照：

总和/合计: 多个部分相加。

差/比…多/少: 用差值或相对量；“比…多x”=“基准+x”。

倍数: 条形图等分；“甲是乙的
𝑘
倍”→甲=
𝑘
⋅
乙。

平均数: 平均=总量÷份数；总量=平均×份数。

单价—数量—总价: 
总价
=
单价
×
数量
。

路程—速度—时间: 
路程
=
速度
×
时间
。

表示法建议：

条形图: 适合总-部分、差、倍数。

表格: 适合多对象多维度（人/物×数量/单价/总价）。

线段时间轴: 适合先后变化类（增减、折扣、分段）。

典型示例（全流程演示）
示例一：两步运算，直接与间接条件结合
题目：文具店有钢笔24支，圆珠笔的数量比钢笔多一半。两种笔一共有多少支？

读题与标注

直接条件: 钢笔24支。

间接条件: “圆珠笔比钢笔多一半”= 圆珠笔 = 钢笔 + 钢笔的一半。

问题: 求总数（支）。

条件结构化与可视化

条形图: 钢笔=2单元，圆珠笔=2单元+1单元（钢笔的一半）。

关系式雏形:

圆珠笔 = 
24
+
1
2
×
24

总数 = 钢笔 + 圆珠笔

计划

先求圆珠笔数量，再求总数。 先有部分，再汇总。

计算

圆珠笔：

24
+
1
2
×
24
=
24
+
12
=
36
 支
总数：

24
+
36
=
60
 支
复核

估算: 圆珠笔约为钢笔的1.5倍，
1.5
×
24
=
36
，符合。

单位: 全程“支”。

条件使用: 均已使用。

答：60支。

示例二：多步运算，含中间量与单位核对
题目：一本书有180页，小明第一天看了全书的四分之一，第二天看了45页，还剩多少页没看？

信息提炼

直接条件: 总页180；第二天45页。

间接条件: “第一天四分之一”= 
1
4
×
180
。

问题: 求剩余页数（页）。

计划

中间目标1: 求第一天页数。

中间目标2: 求已看总页数。

最终: 求剩余 = 总页 - 已看。

计算

第一天：

1
4
×
180
=
45
 页
已看总计：

45
+
45
=
90
 页
剩余：

180
−
90
=
90
 页
复核

对称性检查: 看了一半还剩一半，逻辑通顺。

单位一致: 页。

答：还剩90页。

易错点与即时纠错策略
概念误判（“多一半”vs“多一倍”）

对策: 让学生口头改写：

多一半: “在原来基础上再加一半”= 
1.5
𝑥
。

多一倍: “在原来基础上再加一个原量”= 
2
𝑥
。

可视化: 条形图画出“原量 + 追加部分”的长度差异。

单位混乱

对策: 规定“无单位不下笔”。每步结果右侧必须写单位。

跨类别相加

对策: 先“同类化”，必要时先做单位换算或归类汇总。

漏用条件或过度假设

对策: 条件清单打钩法：每条条件标注“已用/未用/解释性”。

一步做两件事

对策: 拆步；每步只出现一个核心运算与明确来龙去脉。

渐进式支架与话术
全引导（教师主导）

话术:

读题: “把所有数字和单位圈出来，读出关键词。”

条件分类: “哪句是直接给的数？哪句需要转化才好用？”

问题定位: “用自己的话说：求什么？单位是什么？”

图示: “用条形图画出‘总—部分—差/倍’。”

计划: “要得到答案，先要知道什么？这些从哪条条件来？”

半引导（共同完成）

话术:

“把中间目标写成三步链条。”

“每步写出使用的条件编号与原因。”

放手练（学生独立）

要求: 按“读—表—图—链—算—检”六件套提交，附自评表。

可复用模板与清单
学生作答模板（打印发放）
题目再述： 用自己的话复述题意（不超过两行）。

条件清单：

直接条件: ……

间接/隐含条件与转化： ……

图或表： 条形图/表格（标单位）。

目标链： 目标1 → 目标2 → … → 最终。

步骤与计算：

步骤1（用到的条件：#…）：

步骤2（用到的条件：#…）：

复核： 条件核对✓ 单位✓ 估算✓ 逆推✓

答案句： 用语文句式完整表述并带单位。

教师批改与反馈要点
结构分: 是否齐备“清单—图—链—算—检”。

概念分: 关键词理解是否正确（倍、差、平均、速时路）。

过程分: 步骤合理、每步有依据、单位标注。

结果分: 数值正确、表述规范。

反思分: 能指出易错点与迁移场景。

进阶与迁移
类型化训练路径：

阶段1: 总分与差倍（条形图熟练）。

阶段2: 平均与单价数量总价（表格法）。

阶段3: 速时路与分段问题（时间轴与分段运算）。

阶段4: 综合题（多关系混合，先做“依赖图”：哪个量依赖哪个量）。

元认知句型卡：

任务确认: “我求的是……单位是……是否唯一？”

缺口定位: “要得到它，还缺……能用……推出。”

合理性: “结果比……大/小是合理的吗？估算是否相符？”

如果你愿意，我可以按你班级的年级与常见题型，批量生成“条形图模板+表格模板+逐步话术”的练习包，并配套答案与易错点评。你希望先从哪一类题开始（如差倍、平均、单价数量总价、速时路）？

我想要根据这个思路编写一个数学练习系统软件，通过分步引导，设立选择题的形式来完成每道题的思考，然后把所有题都统一成一个统一的格式，然后输出 json 格式文件，请帮我整理一下思路，请调用你的最大算力并结合你的知识库深入详细解析一下
系统概览与目标
你要的是“把解题过程拆成稳定的步骤，用选择题逐步引导，统一到一种可批量生产、可导出的 JSON 格式”。核心就是把“读—析—建—算—检”的思维路径转译成一台可执行的“状态机”，每个状态是一个小选择题，学生用选项“走完”一条高质量的解题路线。下面给出完整的数据模型、流程与可复用模板，支持规模化出题与分析。

内容模型与统一 JSON 结构
将一道题抽象为 Item（题目）→ Steps（分步）→ Options（选项）→ Transitions（路由）→ Scoring（计分）→ Feedback（反馈）。为批量生成与版本化，建议顶层用 ProblemSet 容器。

核心实体与字段
ProblemSet: 整套练习的容器，包含版本、学段、知识图谱锚点、语言环境。

Item: 单题载体，含题干、变量、素材、标签、难度、I/O 规格。

Step: 分步节点（状态），每步只有一个明确的子任务（读题、抽条件、建关系、选策略、选运算、核对）。

Option: 选项集合，含正确性、干扰类型、反馈、可多选配置。

Transition: 基于作答路由到下一步或反馈循环（含最大重试、hint 升级）。

Scoring: 步级与题级分值、加权、惩罚、时间因素。

Hints & Feedback: 分层提示与针对性讲解（短文本 + 可选图示）。

Variables: 参数化出题的变量与生成表达式（确保同一结构可批量实例化）。

Validation: 单位校验、数值区间、逻辑一致性（如条件全用、单位一致）。

Telemetry: 可选埋点键值（用时、重试、路径）。

JSON Schema（简化版，Draft-07）
json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ProblemSet",
  "type": "object",
  "required": ["id", "version", "locale", "metadata", "items"],
  "properties": {
    "id": {"type": "string"},
    "version": {"type": "string"},
    "locale": {"type": "string", "enum": ["zh-CN"]},
    "metadata": {
      "type": "object",
      "properties": {
        "gradeBand": {"type": "string"},
        "subject": {"type": "string"},
        "tags": {"type": "array", "items": {"type": "string"}},
        "createdAt": {"type": "string"},
        "author": {"type": "string"}
      }
    },
    "items": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["id", "stem", "steps", "scoring", "taxonomy"],
        "properties": {
          "id": {"type": "string"},
          "stem": {
            "type": "object",
            "required": ["text"],
            "properties": {
              "text": {"type": "string"},
              "assets": {"type": "array", "items": {"type": "string"}},
              "variables": {
                "type": "object",
                "additionalProperties": {
                  "type": "object",
                  "properties": {
                    "type": {"type": "string", "enum": ["int", "float", "choice"]},
                    "range": {
                      "type": "object",
                      "properties": {"min": {"type": "number"}, "max": {"type": "number"}}
                    },
                    "choices": {"type": "array", "items": {"type": "number"}},
                    "constraints": {"type": "array", "items": {"type": "string"}}
                  }
                }
              }
            }
          },
          "taxonomy": {
            "type": "object",
            "properties": {
              "concepts": {"type": "array", "items": {"type": "string"}},
              "skills": {"type": "array", "items": {"type": "string"}},
              "difficulty": {"type": "string", "enum": ["E", "M", "H"]}
            }
          },
          "steps": {
            "type": "array",
            "items": {
              "type": "object",
              "required": ["id", "type", "prompt", "options"],
              "properties": {
                "id": {"type": "string"},
                "type": {
                  "type": "string",
                  "enum": ["read", "extract", "question", "relation", "plan", "compute", "check"]
                },
                "prompt": {"type": "string"},
                "options": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["id", "text", "correct"],
                    "properties": {
                      "id": {"type": "string"},
                      "text": {"type": "string"},
                      "correct": {"type": "boolean"},
                      "distractorType": {"type": "string"},
                      "feedback": {"type": "string"},
                      "nextStep": {"type": "string"}
                    }
                  }
                },
                "multipleSelect": {"type": "boolean"},
                "hints": {"type": "array", "items": {"type": "string"}},
                "validation": {
                  "type": "object",
                  "properties": {
                    "unit": {"type": "string"},
                    "mustUseConditions": {"type": "array", "items": {"type": "string"}}
                  }
                },
                "telemetryKeys": {"type": "array", "items": {"type": "string"}}
              }
            }
          },
          "scoring": {
            "type": "object",
            "properties": {
              "total": {"type": "number"},
              "perStep": {
                "type": "object",
                "additionalProperties": {
                  "type": "object",
                  "properties": {
                    "score": {"type": "number"},
                    "penaltyPerRetry": {"type": "number"},
                    "minScore": {"type": "number"},
                    "timeBonus": {"type": "number"}
                  }
                }
              }
            }
          },
          "transitions": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "fromStep": {"type": "string"},
                "onWrong": {"type": "string"},
                "onCorrect": {"type": "string"},
                "maxRetries": {"type": "integer"}
              }
            }
          },
          "answer": {
            "type": "object",
            "properties": {
              "final": {"type": "string"},
              "unit": {"type": "string"},
              "rationale": {"type": "string"}
            }
          }
        }
      }
    }
  }
}
分步引导的状态机设计
步骤类型与目标对齐
读题 read: 识别主体、单位、数字范围，建立语境。

产出: 题目类型/场景判断（单价问题、差倍、速时路）。

抽条件 extract: 分类直接条件与间接/隐含条件。

产出: 条件清单（选择题形式：哪些属于直接条件）。

明确问题 question: 确认“求什么、单位”。

产出: 目标对象与单位锁定。

建立关系 relation: 选择正确的数量关系或图示映射。

产出: 关系式雏形或图示选择（如条形图版本A/B）。

制定计划 plan: 决定先后顺序与所需中间量。

产出: 步骤链（1→2→3），每步用到哪些条件。

执行运算 compute: 关键运算节点（每次只做一个核心运算）。

产出: 中间数值或公式选择。

检查校验 check: 单位、数量级、条件使用完整性、逆向验证。

产出: 合理性判断选项。

选项与干扰项策略
正确项设计: 只对齐一个明确子目标，避免“一步两算”。

干扰项类型:

单位误配型: 正确数值+错误单位。

关系误读型: “多一半”与“多一倍”错置。

运算次序型: 应先求中间量却直接合并。

边界估计型: 数量级明显偏大/偏小。

反馈绑定: 每种干扰项附“定制化短反馈+对策提示”。

路由与重试
正确路由: 进入下一步或跳过冗余步（自适应加速）。

错误路由: 给一级提示→再错给二级提示→再错进入“微讲解卡片”→回到同一步。

最大重试: 每步建议 2–3 次，之后提供“看示例→继续”。

计分、适应性与掌握度
计分模型
步级计分: 每步基础分 + 重试惩罚（如每次 -20%），不低于 minScore。

时间加成: 在合理时限内加小额奖励，防止拖沓。

题级加权: 关键步骤（relation、plan、check）权重略高于 compute。

自适应策略
加速通过: 连续正确则省略低层次步（read/extract），直达 relation/plan。

精准补救: 某干扰项被选择→自动追加“同型迷你题”或“微讲解”。

掌握度记录: 按概念与技能维度打点，如“倍数关系识别”“单位一致性”。

出题与生产工作流
从原题到可执行 Item 的五步法
题型分类与意图标注

标签: 概念（如“倍数、条形图、平均”）、技能（“条件分类、关系建模”）。

变量化题干

动作: 把固定数字替换为变量，设置范围与约束（保证整除/合理量级）。

分步拆解与关键错误映射

动作: 对每步列正确子结论，并为每个常错点设计干扰项与针对性反馈。

路由图与重试策略

动作: 为每步定义 onCorrect/onWrong 与提示层级、最大重试次数。

验证与试运行

动作: 校验单位、变量边界、算式合法性；抽样生成若干实例做自动回归测试。

可复用分步模板（按题型）
差倍问题（条形图）

Step 序列: read → extract → question → relation(选条形图) → plan → compute(倍数或差量) → check

关键干扰: “多一半/多一倍”、条形图分段错误。

平均与总量

Step 序列: read → extract → relation(平均三式) → plan → compute → check

关键干扰: 把“总量÷份数”误做“份数÷总量”。

单价—数量—总价

Step 序列: read → extract → relation(三式互推) → plan → compute → check

关键干扰: 单位错配（元/角/分）、合并跨类量。

速时路

Step 序列: read → extract → relation(路=速×时) → plan(分段/统一单位) → compute → check

关键干扰: 小时与分钟换算遗漏、分段路线相加错误。

导入导出与版本管理
文件组织: 一个 ProblemSet 一个 JSON；大项目可按学段/概念拆分多文件。

ID 规范: problemSet.id、item.id、step.id 全局唯一（建议短 UUID）。

版本字段: problemSet.version 与 item 的 semver；重大改动升级主版本。

本地化: locale=zh-CN，文本与单位在同一版本内保持一致；如多语，用 i18n map。

校验: 通过 JSON Schema 自动校验；构建环节做变量约束与可解性检查。

安全备份: 生成 SHA-256 摘要写入 metadata 以追踪变更。

数据与教学分析
核心埋点:

每步: 用时、重试次数、选项 ID、提示层级、路径。

题级: 完成时长、得分、跳过/放弃。

指标看板:

准确率分解: 按概念/技能/干扰类型。

稳定错误: 高频干扰项 TopN → 反向优化题干/提示。

学习曲线: 掌握度随时间的变化（如“单位一致性”从 0.4→0.75）。

示例 Item（含分步与路由）
以“钢笔24支，圆珠笔比钢笔多一半，两种笔共多少支？”为例。

json
{
  "id": "pset-prim-ops-001",
  "version": "1.0.0",
  "locale": "zh-CN",
  "metadata": {
    "gradeBand": "G3-G4",
    "subject": "Math",
    "tags": ["差倍", "条形图", "两步运算"],
    "createdAt": "2025-09-16T15:30:00Z",
    "author": "w"
  },
  "items": [
    {
      "id": "item-0001",
      "stem": {
        "text": "文具店有钢笔${a}支，圆珠笔的数量比钢笔多一半。两种笔一共有多少支？",
        "variables": {
          "a": {"type": "int", "range": {"min": 12, "max": 48}, "constraints": ["a % 2 == 0"]}
        }
      },
      "taxonomy": {
        "concepts": ["倍数关系", "总-部分"],
        "skills": ["条件分类", "关系建模", "两步运算"],
        "difficulty": "M"
      },
      "steps": [
        {
          "id": "s1",
          "type": "extract",
          "prompt": "下列哪些属于直接条件？（可多选）",
          "multipleSelect": true,
          "options": [
            {"id": "s1o1", "text": "钢笔有${a}支", "correct": true, "feedback": "直接给出具体数量"},
            {"id": "s1o2", "text": "圆珠笔是钢笔的1.5倍", "correct": false, "distractorType": "inference", "feedback": "这是推理后的等价表述，属于间接条件"},
            {"id": "s1o3", "text": "求两种笔的总数", "correct": false, "distractorType": "goal-vs-condition", "feedback": "这是问题目标，不是条件"}
          ],
          "hints": ["先找题干中的具体数字和单位", "哪些信息无需计算即可使用？"]
        },
        {
          "id": "s2",
          "type": "question",
          "prompt": "本题要求什么？单位是什么？",
          "options": [
            {"id": "s2o1", "text": "圆珠笔的数量，单位：支", "correct": false, "feedback": "这只是中间量"},
            {"id": "s2o2", "text": "两种笔的总数，单位：支", "correct": true, "feedback": "正确：总数与单位匹配"},
            {"id": "s2o3", "text": "钢笔数量，单位：支", "correct": false, "feedback": "已知，不是要求"}
          ]
        },
        {
          "id": "s3",
          "type": "relation",
          "prompt": "以下哪个关系式最合适？",
          "options": [
            {
              "id": "s3o1",
              "text": "圆珠笔 = 钢笔 + 钢笔的一半；总数 = 钢笔 + 圆珠笔",
              "correct": true,
              "feedback": "把“多一半”转为可计算的关系"
            },
            {
              "id": "s3o2",
              "text": "圆珠笔 = 钢笔 × 2；总数 = 钢笔 + 圆珠笔",
              "correct": false,
              "distractorType": "倍数误解",
              "feedback": "把“多一半”误解成“多一倍”"
            },
            {
              "id": "s3o3",
              "text": "总数 = 钢笔 × 圆珠笔",
              "correct": false,
              "distractorType": "结构错误",
              "feedback": "总数是相加关系，不是相乘"
            }
          ],
          "hints": ["“多一半”= 原来再加上一半", "先得到圆珠笔，再求总数"]
        },
        {
          "id": "s4",
          "type": "plan",
          "prompt": "最合理的解题步骤是？",
          "options": [
            {"id": "s4o1", "text": "先求圆珠笔数量，再求两种笔总数", "correct": true, "feedback": "先部分后整体"},
            {"id": "s4o2", "text": "直接把钢笔数量×1.5得到总数", "correct": false, "distractorType": "结构误配", "feedback": "总数需要两种笔相加"}
          ]
        },
        {
          "id": "s5",
          "type": "compute",
          "prompt": "圆珠笔的数量是多少？",
          "options": [
            {"id": "s5o1", "text": "${a} + ${a}/2", "correct": true, "feedback": "等式正确，数值为 ${a + a/2} 支"},
            {"id": "s5o2", "text": "${a} × 2", "correct": false, "distractorType": "倍数误解", "feedback": "这是“多一倍”"},
            {"id": "s5o3", "text": "${a}/2", "correct": false, "distractorType": "漏加原量", "feedback": "忘记加上“原来的”${a}"}
          ],
          "validation": {"unit": "支"}
        },
        {
          "id": "s6",
          "type": "compute",
          "prompt": "两种笔一共有多少支？",
          "options": [
            {"id": "s6o1", "text": "${a} + (${a} + ${a}/2)", "correct": true, "feedback": "合并得到 ${(3*a)/2} 支"},
            {"id": "s6o2", "text": "${a} × 1.5", "correct": false, "distractorType": "漏加另一类", "feedback": "只包含圆珠笔，不包含两类相加"}
          ],
          "validation": {"unit": "支"},
          "hints": ["总数是两类相加"]
        },
        {
          "id": "s7",
          "type": "check",
          "prompt": "以下哪项最能验证结果合理？",
          "options": [
            {"id": "s7o1", "text": "圆珠笔约为钢笔的1.5倍，总数应约为2.5倍的钢笔数", "correct": true, "feedback": "数量级合理"},
            {"id": "s7o2", "text": "总数应小于钢笔数量", "correct": false, "distractorType": "单调性错误", "feedback": "总数必大于任一部分"}
          ]
        }
      ],
      "transitions": [
        {"fromStep": "s1", "onCorrect": "s2", "onWrong": "s1", "maxRetries": 2},
        {"fromStep": "s2", "onCorrect": "s3", "onWrong": "s2", "maxRetries": 2},
        {"fromStep": "s3", "onCorrect": "s4", "onWrong": "s3", "maxRetries": 2},
        {"fromStep": "s4", "onCorrect": "s5", "onWrong": "s4", "maxRetries": 2},
        {"fromStep": "s5", "onCorrect": "s6", "onWrong": "s5", "maxRetries": 2},
        {"fromStep": "s6", "onCorrect": "s7", "onWrong": "s6", "maxRetries": 2},
        {"fromStep": "s7", "onCorrect": "", "onWrong": "s7", "maxRetries": 1}
      ],
      "scoring": {
        "total": 10,
        "perStep": {
          "s1": {"score": 1, "penaltyPerRetry": 0.2, "minScore": 0.2},
          "s2": {"score": 1, "penaltyPerRetry": 0.2, "minScore": 0.2},
          "s3": {"score": 2, "penaltyPerRetry": 0.4, "minScore": 0.4},
          "s4": {"score": 2, "penaltyPerRetry": 0.4, "minScore": 0.4},
          "s5": {"score": 2, "penaltyPerRetry": 0.4, "minScore": 0.4},
          "s6": {"score": 1, "penaltyPerRetry": 0.2, "minScore": 0.2},
          "s7": {"score": 1, "penaltyPerRetry": 0.2, "minScore": 0.2}
        }
      },
      "answer": {
        "final": "(3/2)×${a}",
        "unit": "支",
        "rationale": "由“多一半”得圆珠笔=1.5×钢笔，总数=钢笔+圆珠笔=2.5×钢笔"
      }
    }
  ]
}
说明：变量 a 将在渲染时实例化；可在构建阶段生成多个不同 a 的具体 Item 实例，形成批量题库。

前端流程与交互要点
最少即最强 UI: 每步只显示一件事：题干固定在侧栏，当前步提示在主区。

单位可视化: 在 compute 步“单位栏”常驻提醒，错误时高亮。

提示渐进: 点击“需要提示”才展开，避免打断流。

跳步逻辑: 连续 2 步一拍即合可触发“快速通道”，进入 relation 或 plan。

可视化组件: 条形图/时间轴，作为 relation/plan 的选项之一（可选择“图A/图B”）。

质量保障与边界情况
变量约束: 保证分数/整除（如平均数、半数），避免小数给低年级。

单位统一: 在 schema 校验“步级 unit 一致性”，遇到混合单位必须在 plan 步先换算。

不可解检测: 自动检查 mustUseConditions 是否可在路线中全部覆盖。

干扰项审查: 每个干扰项对应唯一、可命名的错误类型，便于统计与教研复盘。

可访问性: 选项长度控制，避免阅读负担；关键术语支持高亮与术语卡。

如果你愿意，我可以按你打算覆盖的知识图谱（如“差倍、平均、单价数量总价、速时路”）批量产出可直接使用的 JSON 题库雏形，并配套自动化校验脚本的规则清单。告诉我你的年级段与首批题量目标（例如每类各50题），我就给你第一版可导入文件与变量约束。

我应该如何设计用户界面？
好的 w，我们可以把你的数学分步引导系统的 UI 设计 拆成三个层次来考虑：信息结构、交互流程、视觉呈现。目标是让小学生在界面中“看得懂、点得准、走得顺”，同时方便你批量生成和统一格式化题目。

1. 信息结构（Information Architecture）
核心原则
固定区 + 动态区：题干和关键信息固定在一个区域，分步引导内容在另一个区域动态切换。

最少干扰：每一步只呈现一件事，避免信息过载。

可回溯：学生可以回看前一步的提示或自己的选择。

推荐布局
区域	功能	设计要点
左侧/顶部固定栏	题干、插图、变量值	- 题干常驻，变量高亮<br>- 支持简单图示（条形图、表格）<br>- 单位用颜色或图标标识
主交互区	当前步骤的选择题	- 大字号、选项间距大<br>- 每个选项可点击后立即反馈<br>- 支持多选（有明显提示）
辅助区	提示、反馈、进度	- 提示分层展开<br>- 进度条或步骤编号<br>- 错误反馈简短直白
2. 交互流程（Interaction Flow）
分步引导的 UI 节奏
Step Header：显示当前步骤类型（如“提取条件”）+ 简短说明。

Prompt 区：当前问题的文字/图示。

Options 区：选择题选项，点击即判对错。

即时反馈：

正确：绿色勾 + 简短肯定语 + 下一步按钮。

错误：红色叉 + 针对性提示（可展开详细解释）。

进度指示：顶部或侧边显示“第 X 步 / 共 Y 步”。

可选的“回顾”按钮：回看前一步的题干和自己选的答案。

关键交互细节
防误触：选项按钮大、间距足够，适合触屏。

提示渐进：第一次错给轻提示，再错给详细讲解。

单位常驻提醒：在计算步，单位显示在输入框或选项旁。

图文结合：relation/plan 步骤可直接点选图示（如条形图版本A/B）。

3. 视觉呈现（Visual Design）
色彩与层级
主色：温暖明亮（如蓝绿系），降低紧张感。

反馈色：绿色=正确，红色=错误，黄色=提示。

高亮：数字、单位、关键词用背景色或描边突出。

字体与排版
题干：大字号、行距适中，便于低年级阅读。

选项：每个选项独立卡片式，点击范围大。

图示：简洁、色块分明，避免复杂细节。

动画与过渡
轻微过渡：正确/错误反馈用淡入淡出，不要闪烁。

进度变化：进度条平滑增长，给成就感。

4. 针对你系统的特别建议
结合你要批量生成 JSON 题库的需求，UI 还应支持：

动态渲染：从 JSON 自动生成题干、选项、图示。

变量替换高亮：变量值在题干中用特殊样式标出。

多题型兼容：单选、多选、图形选择、填空（可后期扩展）。

教师模式：显示正确答案、干扰项类型、学生作答路径。

5. 示例界面草图（文字描述）
代码
┌───────────────────────────────┐
│ 题干区（固定）                 │
│ 文具店有钢笔 24 支，圆珠笔比... │
│ [条形图示意]                   │
└───────────────────────────────┘

[步骤 2/7] 本题要求什么？单位是什么？
( ) 圆珠笔的数量，单位：支
(●) 两种笔的总数，单位：支
( ) 钢笔数量，单位：支

[正确] ✅ 总数与单位匹配
[下一步 →]

进度条: ███░░░░░░  2/7
如果你愿意，我可以帮你画一个 完整的 UI 流程图，把每个步骤的界面状态、按钮、反馈、路由都标出来，这样你在开发时可以直接交给前端实现。 你是想让我先画 低保真线框图 还是直接给你 高保真配色方案 的版本？

帮我生成一个完整的页面，请调用你的最大算力并结合你的知识库深入详细解析一下
单页原型代码与说明
下面是一个可直接运行的前端单页，包含：固定题干区、分步引导、单选/多选、提示分层、即时反馈、进度条、路由跳转、计分、变量替换与一个示例题目。将代码保存为 html 文件，在浏览器中打开即可体验。

运行说明
使用方式: 将下方代码保存为 math_trainer.html，用浏览器打开。

核心能力: 从内置 JSON 题集加载数据，渲染分步流程，完成选项判断、提示、反馈、进度与得分。

扩展点: 代码内以 TODO 标注的地方可接入你的题库生成与 Schema 校验。

可运行页面代码
html
<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>分步引导数学练习 | 原型</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #f7f9fc;
      --panel: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --primary: #2563eb;
      --primary-weak: #dbeafe;
      --ok: #16a34a;
      --err: #dc2626;
      --warn: #d97706;
      --border: #e5e7eb;
      --chip: #eef2ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans SC", "PingFang SC", "Microsoft YaHei", Arial, sans-serif;
      color: var(--text); background: var(--bg);
    }
    header {
      background: var(--panel); border-bottom: 1px solid var(--border);
      padding: 12px 16px; position: sticky; top: 0; z-index: 10;
      display: flex; gap: 12px; align-items: center; justify-content: space-between;
    }
    header .brand { font-weight: 700; color: var(--primary); }
    header .meta { font-size: 12px; color: var(--muted); }
    main { display: grid; gap: 16px; grid-template-columns: 380px 1fr; padding: 16px; max-width: 1200px; margin: 0 auto; }
    @media (max-width: 960px) { main { grid-template-columns: 1fr; } }
    .panel {
      background: var(--panel); border: 1px solid var(--border); border-radius: 10px; padding: 16px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.03);
    }
    .stem h2 { font-size: 16px; margin: 0 0 8px; color: var(--muted); }
    .stem .text { font-size: 18px; line-height: 1.6; }
    .tags { margin-top: 8px; display: flex; flex-wrap: wrap; gap: 6px; }
    .chip { background: var(--chip); color: #3730a3; border: 1px solid #c7d2fe; padding: 2px 8px; border-radius: 999px; font-size: 12px; }
    .vars { margin-top: 8px; font-size: 14px; color: var(--muted); }
    .progress {
      width: 100%; height: 10px; background: #f1f5f9; border-radius: 999px; overflow: hidden; margin: 10px 0 4px;
    }
    .bar { height: 100%; background: linear-gradient(90deg, var(--primary), #22c55e); width: 0%; transition: width .25s ease; }
    .step-hdr {
      display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;
    }
    .step-type { font-size: 13px; color: var(--muted); }
    .step-idx { font-size: 13px; color: var(--muted); }
    .prompt { font-size: 18px; margin: 8px 0 12px; }
    .options { display: grid; gap: 10px; }
    .opt {
      border: 1px solid var(--border); border-radius: 10px; padding: 12px; background: #fff; cursor: pointer; transition: border .15s, background .15s, transform .05s;
    }
    .opt:hover { border-color: var(--primary); }
    .opt.selected { border-color: var(--primary); background: var(--primary-weak); }
    .opt.correct { border-color: var(--ok); }
    .opt.wrong { border-color: var(--err); }
    .btns { display: flex; gap: 10px; margin-top: 12px; flex-wrap: wrap; }
    button {
      appearance: none; border: 1px solid var(--border); background: #fff; color: var(--text);
      padding: 8px 12px; border-radius: 8px; cursor: pointer; transition: background .15s, transform .05s;
    }
    button.primary { background: var(--primary); border-color: var(--primary); color: #fff; }
    button:active { transform: translateY(1px); }
    .feedback {
      margin-top: 10px; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: #f8fafc; font-size: 14px;
    }
    .feedback.ok { border-color: #bbf7d0; background: #f0fdf4; color: var(--ok); }
    .feedback.err { border-color: #fecaca; background: #fef2f2; color: var(--err); }
    .hint {
      margin-top: 8px; border-left: 3px solid var(--warn); background: #fffbeb; padding: 8px 10px; border-radius: 6px; color: #92400e; font-size: 14px;
    }
    .footer {
      font-size: 12px; color: var(--muted); margin-top: 10px; display: flex; justify-content: space-between; flex-wrap: wrap; gap: 6px;
    }
    .score { font-weight: 700; color: var(--primary); }
    .telemetry { font-size: 12px; color: var(--muted); max-height: 120px; overflow: auto; background: #f8fafc; border: 1px dashed var(--border); padding: 8px; border-radius: 8px; }
    .unit-pill { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #ecfeff; border: 1px solid #a5f3fc; color: #0e7490; font-size: 12px; margin-left: 6px; }
    .legend { font-size: 12px; color: var(--muted); display: flex; gap: 8px; flex-wrap: wrap; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: #f3f4f6; border: 1px solid #e5e7eb; border-bottom-width: 2px; padding: 0 6px; border-radius: 6px; }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <header>
    <div>
      <div class="brand">分步引导数学练习</div>
      <div class="meta">原型版 · 单页应用</div>
    </div>
    <div class="legend">
      <span>正确 <span style="color:var(--ok)">●</span></span>
      <span>错误 <span style="color:var(--err)">●</span></span>
      <span>提示 <span style="color:var(--warn)">●</span></span>
    </div>
  </header>

  <main>
    <aside class="panel stem" id="stemPanel">
      <h2>题目</h2>
      <div class="text" id="stemText"></div>
      <div class="vars" id="varInfo"></div>
      <div class="tags" id="tags"></div>

      <div style="margin-top:12px">
        <div style="font-size:12px;color:var(--muted);margin-bottom:6px;">进度</div>
        <div class="progress"><div class="bar" id="progressBar"></div></div>
        <div class="footer">
          <div id="stepCounter">第 0/0 步</div>
          <div>当前单位 <span class="unit-pill" id="unitPill">—</span></div>
        </div>
      </div>
    </aside>

    <section class="panel" id="workPanel">
      <div class="step-hdr">
        <div class="step-type" id="stepType">—</div>
        <div class="step-idx" id="stepIdx">—</div>
      </div>
      <div class="prompt" id="prompt">—</div>
      <div class="options" id="options"></div>

      <div class="feedback hidden" id="feedbackBox"></div>
      <div class="hint hidden" id="hintBox"></div>

      <div class="btns">
        <button id="showHintBtn">需要提示</button>
        <button class="primary" id="confirmBtn">确认</button>
        <button id="nextBtn" class="hidden">下一步</button>
        <button id="prevBtn">上一步</button>
        <button id="resetBtn">重做本题</button>
      </div>

      <div class="footer">
        <div>分值 <span class="score" id="scoreNow">0</span> / <span id="scoreTotal">0</span></div>
        <div id="timer">⏱️ 0s</div>
      </div>

      <div style="margin-top:10px">
        <div style="font-size:12px;color:var(--muted);margin-bottom:6px;">作答记录</div>
        <div class="telemetry" id="telemetry"></div>
      </div>
    </section>
  </main>

  <script>
    // --- Sample ProblemSet (可替换为你的后端/本地文件载入) ---
    const ProblemSet = {
      id: "pset-prim-ops-001",
      version: "1.0.0",
      locale: "zh-CN",
      metadata: {
        gradeBand: "G3-G4",
        subject: "Math",
        tags: ["差倍", "条形图", "两步运算"],
        createdAt: "2025-09-16T15:30:00Z",
        author: "w"
      },
      items: [
        {
          id: "item-0001",
          stem: {
            text: "文具店有钢笔${a}支，圆珠笔的数量比钢笔多一半。两种笔一共有多少支？",
            variables: { a: { type: "int", range: { min: 12, max: 48 }, constraints: ["a % 2 == 0"] } }
          },
          taxonomy: {
            concepts: ["倍数关系", "总-部分"],
            skills: ["条件分类", "关系建模", "两步运算"],
            difficulty: "M"
          },
          steps: [
            {
              id: "s1",
              type: "extract",
              prompt: "下列哪些属于直接条件？（可多选）",
              multipleSelect: true,
              options: [
                { id: "s1o1", text: "钢笔有${a}支", correct: true, feedback: "直接给出具体数量" },
                { id: "s1o2", text: "圆珠笔是钢笔的1.5倍", correct: false, distractorType: "inference", feedback: "这是推理后的表述，属于间接条件" },
                { id: "s1o3", text: "求两种笔的总数", correct: false, distractorType: "goal-vs-condition", feedback: "这是问题目标，不是条件" }
              ],
              hints: ["先找题干中的具体数字和单位", "哪些信息无需计算即可使用？"]
            },
            {
              id: "s2",
              type: "question",
              prompt: "本题要求什么？单位是什么？",
              options: [
                { id: "s2o1", text: "圆珠笔的数量，单位：支", correct: false, feedback: "这是中间量" },
                { id: "s2o2", text: "两种笔的总数，单位：支", correct: true, feedback: "正确：总数与单位匹配" },
                { id: "s2o3", text: "钢笔数量，单位：支", correct: false, feedback: "已知，不是要求" }
              ]
            },
            {
              id: "s3",
              type: "relation",
              prompt: "以下哪个关系式最合适？",
              options: [
                { id: "s3o1", text: "圆珠笔 = 钢笔 + 钢笔的一半；总数 = 钢笔 + 圆珠笔", correct: true, feedback: "把“多一半”转为可计算的关系" },
                { id: "s3o2", text: "圆珠笔 = 钢笔 × 2；总数 = 钢笔 + 圆珠笔", correct: false, distractorType: "倍数误解", feedback: "把“多一半”误解成“多一倍”" },
                { id: "s3o3", text: "总数 = 钢笔 × 圆珠笔", correct: false, distractorType: "结构错误", feedback: "总数是相加关系，不是相乘" }
              ],
              hints: ["“多一半”= 原来再加上一半", "先得到圆珠笔，再求总数"]
            },
            {
              id: "s4",
              type: "plan",
              prompt: "最合理的解题步骤是？",
              options: [
                { id: "s4o1", text: "先求圆珠笔数量，再求两种笔总数", correct: true, feedback: "先部分后整体" },
                { id: "s4o2", text: "直接把钢笔数量×1.5得到总数", correct: false, distractorType: "结构误配", feedback: "总数需要两类相加" }
              ]
            },
            {
              id: "s5",
              type: "compute",
              prompt: "圆珠笔的数量是多少？",
              options: [
                { id: "s5o1", text: "${a} + ${a}/2", correct: true, feedback: "等式正确，数值为 ${a + a/2} 支" },
                { id: "s5o2", text: "${a} × 2", correct: false, distractorType: "倍数误解", feedback: "这是“多一倍”" },
                { id: "s5o3", text: "${a}/2", correct: false, distractorType: "漏加原量", feedback: "忘记加上“原来的”${a}" }
              ],
              validation: { unit: "支" }
            },
            {
              id: "s6",
              type: "compute",
              prompt: "两种笔一共有多少支？",
              options: [
                { id: "s6o1", text: "${a} + (${a} + ${a}/2)", correct: true, feedback: "合并得到 ${(3*a)/2} 支" },
                { id: "s6o2", text: "${a} × 1.5", correct: false, distractorType: "漏加另一类", feedback: "只包含圆珠笔，不包含两类相加" }
              ],
              validation: { unit: "支" },
              hints: ["总数是两类相加"]
            },
            {
              id: "s7",
              type: "check",
              prompt: "以下哪项最能验证结果合理？",
              options: [
                { id: "s7o1", text: "圆珠笔约为钢笔的1.5倍，总数应约为2.5倍的钢笔数", correct: true, feedback: "数量级合理" },
                { id: "s7o2", text: "总数应小于钢笔数量", correct: false, distractorType: "单调性错误", feedback: "总数必大于任一部分" }
              ]
            }
          ],
          transitions: [
            { fromStep: "s1", onCorrect: "s2", onWrong: "s1", maxRetries: 2 },
            { fromStep: "s2", onCorrect: "s3", onWrong: "s2", maxRetries: 2 },
            { fromStep: "s3", onCorrect: "s4", onWrong: "s3", maxRetries: 2 },
            { fromStep: "s4", onCorrect: "s5", onWrong: "s4", maxRetries: 2 },
            { fromStep: "s5", onCorrect: "s6", onWrong: "s5", maxRetries: 2 },
            { fromStep: "s6", onCorrect: "s7", onWrong: "s6", maxRetries: 2 },
            { fromStep: "s7", onCorrect: "", onWrong: "s7", maxRetries: 1 }
          ],
          scoring: {
            total: 10,
            perStep: {
              s1: { score: 1, penaltyPerRetry: 0.2, minScore: 0.2 },
              s2: { score: 1, penaltyPerRetry: 0.2, minScore: 0.2 },
              s3: { score: 2, penaltyPerRetry: 0.4, minScore: 0.4 },
              s4: { score: 2, penaltyPerRetry: 0.4, minScore: 0.4 },
              s5: { score: 2, penaltyPerRetry: 0.4, minScore: 0.4 },
              s6: { score: 1, penaltyPerRetry: 0.2, minScore: 0.2 },
              s7: { score: 1, penaltyPerRetry: 0.2, minScore: 0.2 }
            }
          },
          answer: { final: "(3/2)×${a}", unit: "支", rationale: "圆珠笔=1.5×钢笔，总数=钢笔+圆珠笔=2.5×钢笔" }
        }
      ]
    };

    // --- Utility: 变量替换（支持简单算式求值展示） ---
    function renderTemplate(t, ctx) {
      if (!t || typeof t !== "string") return t;
      return t.replace(/\$\{([^}]+)\}/g, (_, expr) => {
        try {
          const vars = Object.assign({}, ctx);
          // 安全起见，仅允许变量与基本运算
          // eslint-disable-next-line no-new-func
          const fn = new Function(...Object.keys(vars), `return (${expr});`);
          return fn(...Object.values(vars));
        } catch {
          return `?`;
        }
      });
    }

    // --- 简单随机变量实例化（满足偶数约束） ---
    function instantiateVariables(varSpec) {
      const ctx = {};
      for (const [k, spec] of Object.entries(varSpec || {})) {
        if (spec.type === "int") {
          // 简化：只处理偶数约束
          let v = randInt(spec.range?.min ?? 10, spec.range?.max ?? 50);
          if ((spec.constraints || []).includes("a % 2 == 0")) {
            if (k === "a" && v % 2 !== 0) v += 1;
          }
          ctx[k] = v;
        }
      }
      return ctx;
    }
    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

    // --- 应用状态 ---
    const state = {
      itemIdx: 0,
      stepIdx: 0,
      vars: {},
      retries: {}, // stepId -> count
      score: 0,
      startTime: Date.now(),
      stepStart: Date.now(),
      path: [] // telemetry
    };

    // --- DOM refs ---
    const stemText = document.getElementById("stemText");
    const tags = document.getElementById("tags");
    const varInfo = document.getElementById("varInfo");
    const progressBar = document.getElementById("progressBar");
    const stepCounter = document.getElementById("stepCounter");
    const unitPill = document.getElementById("unitPill");
    const stepTypeEl = document.getElementById("stepType");
    const stepIdxEl = document.getElementById("stepIdx");
    const promptEl = document.getElementById("prompt");
    const optionsEl = document.getElementById("options");
    const feedbackBox = document.getElementById("feedbackBox");
    const hintBox = document.getElementById("hintBox");
    const showHintBtn = document.getElementById("showHintBtn");
    const confirmBtn = document.getElementById("confirmBtn");
    const nextBtn = document.getElementById("nextBtn");
    const prevBtn = document.getElementById("prevBtn");
    const resetBtn = document.getElementById("resetBtn");
    const scoreNow = document.getElementById("scoreNow");
    const scoreTotal = document.getElementById("scoreTotal");
    const telemetry = document.getElementById("telemetry");
    const timer = document.getElementById("timer");

    // --- 初始化 ---
    const item = ProblemSet.items[state.itemIdx];
    state.vars = instantiateVariables(item.stem.variables);
    stemText.innerText = renderTemplate(item.stem.text, state.vars);
    varInfo.innerText = "变量: " + Object.entries(state.vars).map(([k,v])=>`${k}=${v}`).join(", ");
    tags.innerHTML = (ProblemSet.metadata.tags || []).map(t => `<span class="chip">${t}</span>`).join("");
    scoreTotal.innerText = item.scoring?.total ?? 0;
    unitPill.innerText = item.answer?.unit || "—";
    renderStep();

    // --- 渲染当前步骤 ---
    function renderStep() {
      const step = item.steps[state.stepIdx];
      if (!step) { renderDone(); return; }
      const total = item.steps.length;
      stepCounter.innerText = `第 ${state.stepIdx + 1}/${total} 步`;
      stepIdxEl.innerText = `步骤 ${state.stepIdx + 1}`;
      stepTypeEl.innerText = mapType(step.type);
      promptEl.innerText = renderTemplate(step.prompt, state.vars);
      feedbackBox.classList.add("hidden");
      hintBox.classList.add("hidden");
      feedbackBox.innerHTML = "";
      hintBox.innerHTML = "";
      nextBtn.classList.add("hidden");
      confirmBtn.disabled = false;
      showHintBtn.disabled = !step.hints || step.hints.length === 0;

      // 进度条
      progressBar.style.width = `${(state.stepIdx) / total * 100}%`;

      // 选项
      optionsEl.innerHTML = "";
      const ms = !!step.multipleSelect;
      step._selection = new Set();
      step.options.forEach(opt => {
        const el = document.createElement("div");
        el.className = "opt";
        el.setAttribute("data-id", opt.id);
        el.innerText = renderTemplate(opt.text, state.vars);
        el.onclick = () => {
          if (ms) {
            if (el.classList.contains("selected")) {
              el.classList.remove("selected");
              step._selection.delete(opt.id);
            } else {
              el.classList.add("selected");
              step._selection.add(opt.id);
            }
          } else {
            // 单选：互斥
            [...optionsEl.children].forEach(c => c.classList.remove("selected"));
            el.classList.add("selected");
            step._selection = new Set([opt.id]);
          }
        };
        optionsEl.appendChild(el);
      });

      // 备注：重置计时
      state.stepStart = Date.now();
      tickTimer();
    }

    function mapType(t) {
      const m = {
        read: "读题",
        extract: "提取条件",
        question: "明确问题",
        relation: "建立关系",
        plan: "制定计划",
        compute: "执行运算",
        check: "检查校验"
      };
      return m[t] || t;
    }

    // --- 确认作答 ---
    confirmBtn.onclick = () => {
      const step = item.steps[state.stepIdx];
      if (!step) return;
      const sel = [...(step._selection || [])];
      if (sel.length === 0) { toast("请选择一个选项"); return; }

      const correctIds = step.options.filter(o => o.correct).map(o => o.id);
      const isMultiple = !!step.multipleSelect;
      const isCorrect = isMultiple
        ? arraysEqual(new Set(sel), new Set(correctIds))
        : (correctIds.length === 1 && sel[0] === correctIds[0]);

      // 标色
      [...optionsEl.children].forEach(el => {
        const id = el.getAttribute("data-id");
        if (correctIds.includes(id)) el.classList.add("correct");
        if (sel.includes(id) && !correctIds.includes(id)) el.classList.add("wrong");
      });

      // 分数 & 反馈
      const stepId = step.id;
      state.retries[stepId] = state.retries[stepId] || 0;
      const retry = state.retries[stepId];

      const per = item.scoring?.perStep?.[stepId];
      if (per) {
        if (isCorrect) {
          const penalty = Math.min(retry * (per.penaltyPerRetry || 0), 1);
          const gain = Math.max((per.score || 0) * (1 - penalty), per.minScore || 0);
          state.score += gain;
        } else {
          state.retries[stepId] += 1;
        }
      }
      scoreNow.innerText = state.score.toFixed(1);

      // 针对性反馈（合并同类项）
      let fb = "";
      if (!isCorrect) {
        const chosen = step.options.filter(o => sel.includes(o.id));
        fb = chosen.map(o => o.feedback).filter(Boolean).join("；");
      } else {
        // 用正确项的反馈给简要正向强化
        const chosen = step.options.filter(o => sel.includes(o.id));
        fb = chosen.map(o => o.feedback).filter(Boolean)[0] || "做得好！";
      }
      feedbackBox.classList.remove("hidden");
      feedbackBox.classList.toggle("ok", isCorrect);
      feedbackBox.classList.toggle("err", !isCorrect);
      feedbackBox.innerText = fb || (isCorrect ? "正确" : "再想想");

      // 路由决策
      const tr = item.transitions.find(t => t.fromStep === stepId);
      const nextId = isCorrect ? tr?.onCorrect : tr?.onWrong;
      const maxR = tr?.maxRetries ?? 2;
      const elapsed = Math.round((Date.now() - state.stepStart) / 1000);

      // Telemetry
      logTL({
        stepId,
        correct: isCorrect,
        selection: sel,
        retries: retry,
        elapsed
      });

      // 下一步按钮显隐
      confirmBtn.disabled = true;
      nextBtn.classList.remove("hidden");
      nextBtn.onclick = () => {
        if (!tr) advance(1);
        else {
          if (!isCorrect && state.retries[stepId] > maxR) {
            // 超过重试：降级给“微讲解”并前进（或停留，按策略）
            hintBox.classList.remove("hidden");
            hintBox.innerText = "小贴士：把“多一半”先转成‘原量 + 一半’，再求总数。";
            // 这里选择“保留在当前步”便于掌握；也可前进。
            // 为演示，仍然保留在当前步。
          } else {
            if (nextId) gotoStep(nextId);
            else advance(1);
          }
        }
      }
    };

    // --- 提示 ---
    showHintBtn.onclick = () => {
      const step = item.steps[state.stepIdx];
      if (!step || !step.hints || step.hints.length === 0) return;
      hintBox.classList.remove("hidden");
      // 分层提示：按已错次数提升强度
      const retry = state.retries[step.id] || 0;
      const idx = Math.min(retry, step.hints.length - 1);
      hintBox.innerText = "提示：" + step.hints[idx];
    };

    // --- 导航 ---
    prevBtn.onclick = () => advance(-1);
    resetBtn.onclick = () => resetItem();

    function advance(delta) {
      state.stepIdx = Math.max(0, Math.min(item.steps.length, state.stepIdx + delta));
      renderStep();
    }
    function gotoStep(stepId) {
      const idx = item.steps.findIndex(s => s.id === stepId);
      if (idx >= 0) {
        state.stepIdx = idx;
        renderStep();
      }
    }

    function renderDone() {
      promptEl.innerText = "已完成本题！";
      optionsEl.innerHTML = "";
      nextBtn.classList.add("hidden");
      confirmBtn.disabled = true;
      const total = item.steps.length;
      progressBar.style.width = "100%";
      stepCounter.innerText = `第 ${total}/${total} 步`;
      feedbackBox.classList.remove("hidden");
      feedbackBox.classList.add("ok");
      feedbackBox.innerHTML = `本题完成。你的得分：<b>${state.score.toFixed(1)}</b> / ${item.scoring?.total ?? 0}`;
      logTL({ done: true, totalScore: state.score });
    }

    function resetItem() {
      state.stepIdx = 0;
      state.retries = {};
      state.score = 0;
      state.startTime = Date.now();
      state.stepStart = Date.now();
      scoreNow.innerText = "0";
      telemetry.innerHTML = "";
      renderStep();
    }

    function toast(msg) {
      feedbackBox.classList.remove("hidden", "ok"); feedbackBox.classList.add("err");
      feedbackBox.innerText = msg;
    }

    // --- 简易计时器 ---
    function tickTimer() {
      const sec = Math.round((Date.now() - state.startTime) / 1000);
      timer.innerText = `⏱️ ${sec}s`;
      requestAnimationFrame(() => setTimeout(tickTimer, 500));
    }

    function logTL(entry) {
      state.path.push({ t: Date.now(), ...entry });
      telemetry.innerText = JSON.stringify(entry, null, 2) + "\n" + telemetry.innerText;
    }

    // --- 变量渲染：渲染选项中的表达式 ---
    // 已在 renderTemplate 中处理；若有复杂单位/小数保留，可在此扩展格式化器。
  </script>
</body>
</html>
关键设计点与扩展建议
数据驱动渲染: 从 JSON 直接驱动“题干—步骤—选项—路由—计分”，无需改写前端逻辑。

渐进式提示: 以重试次数映射提示强度，让学生“够到但不被喂到”。

单位常驻: unitPill 常驻右上，计算步在 schema 中的 validation.unit 可用于校验与高亮。

结果合理性检查: check 步作为最后的元认知把关，帮助形成“估算—逆推”的习惯。

可无障碍与触屏优化: 大尺寸卡片选项、明确状态色、键盘确认（可加 Enter/Space）与 ARIA 标签。

下一步你可以做的事
接入你的题库: 将 ProblemSet 替换为你的 JSON 文件加载；按 schema 批量生成变量与干扰项。

题型组件化: 为 relation 步加入“条形图方案 A/B”图片选项；为速时路加入“单位换算开关”。

掌握度画像: 将 distractorType 汇总到概念/技能维度，构建学生画像并做自适应路由。

导出作答数据: 将 state.path 与成绩打包为 JSON，供老师查看与训练分析。

怎么分步骤引导一个小学生去？比如先读题目，总结出直接条件，间接条件，然后看看题目要求什么，跟条件什么关系，需不需要多步计算等，请把我的思路扩展详细，请调用你的最大算力并结合你的知识库深入详细解析一下
小学生解题的分步骤引导法
你这套思路非常对：读题—提炼条件—明确问题—建立关系—设计步骤—计算与复核。下面我把它扩展成一套可落地的课堂流程、模板与话术，既能手把手带学生走一遍，也能逐步放手让他们独立完成。

教学目标与核心原则
目标聚焦: 让学生形成稳定的“读—想—画/列—算—查”的解题习惯，并能自检自纠。

核心原则:

结构化: 每一步都有固定动作与产出（如圈画、表格、示意图、等式）。

可视化: 用条形图、线段图、单位量表，把抽象关系变成“能看见”的关系。

元认知: 每步问自己“我在做什么？为什么？还缺什么？有没有别解？”

由扶到放: 先全引导，再半引导，最后独立完成并自评。

标准解题流程（可直接落地）
1. 读题与界定范围
第一读（整体感知）： 读出题目主语、场景、数量词。

动作: 用笔画出人物、物品、单位，圈出所有数字和单位。

第二读（提炼条件）： 把信息分为“直接条件”和“间接条件/隐含条件”。

直接条件定义: 题目中明确给出、无需推理即可使用的量或关系。

间接条件定义: 需要转换、推理、或与常识/定义结合才能用的量或关系（如“平均”“比…多”“合计”等）。

第三读（明确问题）： 用自己的话复述“求什么？单位是什么？是否唯一？”

2. 条件整理与信息结构化
条件清单（表格化）：

已知量: 列出每个量、单位、对象（谁的、什么的）。

关系式: 关系关键词与等式/不等式雏形（如“多/少、倍、平均、总和、差、比例、速度时间路程”）。

可视化表示：

条形/线段图: 一看就能看出“总—部分—部分”“倍数”“差值”。

单位量标注: 在图/表上标明单位，避免无单位运算。

3. 分析题目需求与关系匹配
任务拆解: 把“求什么”拆成一到多步的“中间目标”。

动作: 列“目标链”：

目标1 → 目标2 → 目标3 → 最终答案（每个目标旁写可能使用的条件）。

关系匹配: 用“所需→已有”的检核法判断是否需要引入中间量。

提问句: “要得到这个量，我缺什么？这些缺的能由哪些条件推出？”

4. 计算计划设计（而非直接算）
运算路线图: 决定先算哪一步、用什么公式或运算、为什么这样排。

估算与边界: 粗估结果区间，防止数量级错误。

单位核对: 每一步都标单位，确保加减乘除对“同类单位或可转换单位”进行。

5. 执行计算与格式规范
逐步计算: 每步只做一件事，写清“来处”和“去处”。

中间结果标注: 左侧写“步名”（如“求总数”“求单价”），右侧写算式与结果。

6. 复核与反思
三重检查:

条件对照: 每个条件是否被使用或合理解释？

单位与数量级: 单位是否正确、数量是否合理、估算是否匹配？

逆向验证或替代关系: 用反推或另一关系验证一次关键结果。

反思卡片: 本题结构类型、关键词、哪一步最易错、可迁移到哪类题。

常用工具与可视化
关键词—运算对照：

总和/合计: 多个部分相加。

差/比…多/少: 用差值或相对量；“比…多x”=“基准+x”。

倍数: 条形图等分；“甲是乙的
𝑘
倍”→甲=
𝑘
⋅
乙。

平均数: 平均=总量÷份数；总量=平均×份数。

单价—数量—总价: 
总价
=
单价
×
数量
。

路程—速度—时间: 
路程
=
速度
×
时间
。

表示法建议：

条形图: 适合总-部分、差、倍数。

表格: 适合多对象多维度（人/物×数量/单价/总价）。

线段时间轴: 适合先后变化类（增减、折扣、分段）。

典型示例（全流程演示）
示例一：两步运算，直接与间接条件结合
题目：文具店有钢笔24支，圆珠笔的数量比钢笔多一半。两种笔一共有多少支？

读题与标注

直接条件: 钢笔24支。

间接条件: “圆珠笔比钢笔多一半”= 圆珠笔 = 钢笔 + 钢笔的一半。

问题: 求总数（支）。

条件结构化与可视化

条形图: 钢笔=2单元，圆珠笔=2单元+1单元（钢笔的一半）。

关系式雏形:

圆珠笔 = 
24
+
1
2
×
24

总数 = 钢笔 + 圆珠笔

计划

先求圆珠笔数量，再求总数。 先有部分，再汇总。

计算

圆珠笔：

24
+
1
2
×
24
=
24
+
12
=
36
 支
总数：

24
+
36
=
60
 支
复核

估算: 圆珠笔约为钢笔的1.5倍，
1.5
×
24
=
36
，符合。

单位: 全程“支”。

条件使用: 均已使用。

答：60支。

示例二：多步运算，含中间量与单位核对
题目：一本书有180页，小明第一天看了全书的四分之一，第二天看了45页，还剩多少页没看？

信息提炼

直接条件: 总页180；第二天45页。

间接条件: “第一天四分之一”= 
1
4
×
180
。

问题: 求剩余页数（页）。

计划

中间目标1: 求第一天页数。

中间目标2: 求已看总页数。

最终: 求剩余 = 总页 - 已看。

计算

第一天：

1
4
×
180
=
45
 页
已看总计：

45
+
45
=
90
 页
剩余：

180
−
90
=
90
 页
复核

对称性检查: 看了一半还剩一半，逻辑通顺。

单位一致: 页。

答：还剩90页。

易错点与即时纠错策略
概念误判（“多一半”vs“多一倍”）

对策: 让学生口头改写：

多一半: “在原来基础上再加一半”= 
1.5
𝑥
。

多一倍: “在原来基础上再加一个原量”= 
2
𝑥
。

可视化: 条形图画出“原量 + 追加部分”的长度差异。

单位混乱

对策: 规定“无单位不下笔”。每步结果右侧必须写单位。

跨类别相加

对策: 先“同类化”，必要时先做单位换算或归类汇总。

漏用条件或过度假设

对策: 条件清单打钩法：每条条件标注“已用/未用/解释性”。

一步做两件事

对策: 拆步；每步只出现一个核心运算与明确来龙去脉。

渐进式支架与话术
全引导（教师主导）

话术:

读题: “把所有数字和单位圈出来，读出关键词。”

条件分类: “哪句是直接给的数？哪句需要转化才好用？”

问题定位: “用自己的话说：求什么？单位是什么？”

图示: “用条形图画出‘总—部分—差/倍’。”

计划: “要得到答案，先要知道什么？这些从哪条条件来？”

半引导（共同完成）

话术:

“把中间目标写成三步链条。”

“每步写出使用的条件编号与原因。”

放手练（学生独立）

要求: 按“读—表—图—链—算—检”六件套提交，附自评表。

可复用模板与清单
学生作答模板（打印发放）
题目再述： 用自己的话复述题意（不超过两行）。

条件清单：

直接条件: ……

间接/隐含条件与转化： ……

图或表： 条形图/表格（标单位）。

目标链： 目标1 → 目标2 → … → 最终。

步骤与计算：

步骤1（用到的条件：#…）：

步骤2（用到的条件：#…）：

复核： 条件核对✓ 单位✓ 估算✓ 逆推✓

答案句： 用语文句式完整表述并带单位。

教师批改与反馈要点
结构分: 是否齐备“清单—图—链—算—检”。

概念分: 关键词理解是否正确（倍、差、平均、速时路）。

过程分: 步骤合理、每步有依据、单位标注。

结果分: 数值正确、表述规范。

反思分: 能指出易错点与迁移场景。

进阶与迁移
类型化训练路径：

阶段1: 总分与差倍（条形图熟练）。

阶段2: 平均与单价数量总价（表格法）。

阶段3: 速时路与分段问题（时间轴与分段运算）。

阶段4: 综合题（多关系混合，先做“依赖图”：哪个量依赖哪个量）。

元认知句型卡：

任务确认: “我求的是……单位是……是否唯一？”

缺口定位: “要得到它，还缺……能用……推出。”

合理性: “结果比……大/小是合理的吗？估算是否相符？”

如果你愿意，我可以按你班级的年级与常见题型，批量生成“条形图模板+表格模板+逐步话术”的练习包，并配套答案与易错点评。你希望先从哪一类题开始（如差倍、平均、单价数量总价、速时路）？

我想要根据这个思路编写一个数学练习系统软件，通过分步引导，设立选择题的形式来完成每道题的思考，然后把所有题都统一成一个统一的格式，然后输出 json 格式文件，请帮我整理一下思路，请调用你的最大算力并结合你的知识库深入详细解析一下
系统概览与目标
你要的是“把解题过程拆成稳定的步骤，用选择题逐步引导，统一到一种可批量生产、可导出的 JSON 格式”。核心就是把“读—析—建—算—检”的思维路径转译成一台可执行的“状态机”，每个状态是一个小选择题，学生用选项“走完”一条高质量的解题路线。下面给出完整的数据模型、流程与可复用模板，支持规模化出题与分析。

内容模型与统一 JSON 结构
将一道题抽象为 Item（题目）→ Steps（分步）→ Options（选项）→ Transitions（路由）→ Scoring（计分）→ Feedback（反馈）。为批量生成与版本化，建议顶层用 ProblemSet 容器。

核心实体与字段
ProblemSet: 整套练习的容器，包含版本、学段、知识图谱锚点、语言环境。

Item: 单题载体，含题干、变量、素材、标签、难度、I/O 规格。

Step: 分步节点（状态），每步只有一个明确的子任务（读题、抽条件、建关系、选策略、选运算、核对）。

Option: 选项集合，含正确性、干扰类型、反馈、可多选配置。

Transition: 基于作答路由到下一步或反馈循环（含最大重试、hint 升级）。

Scoring: 步级与题级分值、加权、惩罚、时间因素。

Hints & Feedback: 分层提示与针对性讲解（短文本 + 可选图示）。

Variables: 参数化出题的变量与生成表达式（确保同一结构可批量实例化）。

Validation: 单位校验、数值区间、逻辑一致性（如条件全用、单位一致）。

Telemetry: 可选埋点键值（用时、重试、路径）。

JSON Schema（简化版，Draft-07）
json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ProblemSet",
  "type": "object",
  "required": ["id", "version", "locale", "metadata", "items"],
  "properties": {
    "id": {"type": "string"},
    "version": {"type": "string"},
    "locale": {"type": "string", "enum": ["zh-CN"]},
    "metadata": {
      "type": "object",
      "properties": {
        "gradeBand": {"type": "string"},
        "subject": {"type": "string"},
        "tags": {"type": "array", "items": {"type": "string"}},
        "createdAt": {"type": "string"},
        "author": {"type": "string"}
      }
    },
    "items": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["id", "stem", "steps", "scoring", "taxonomy"],
        "properties": {
          "id": {"type": "string"},
          "stem": {
            "type": "object",
            "required": ["text"],
            "properties": {
              "text": {"type": "string"},
              "assets": {"type": "array", "items": {"type": "string"}},
              "variables": {
                "type": "object",
                "additionalProperties": {
                  "type": "object",
                  "properties": {
                    "type": {"type": "string", "enum": ["int", "float", "choice"]},
                    "range": {
                      "type": "object",
                      "properties": {"min": {"type": "number"}, "max": {"type": "number"}}
                    },
                    "choices": {"type": "array", "items": {"type": "number"}},
                    "constraints": {"type": "array", "items": {"type": "string"}}
                  }
                }
              }
            }
          },
          "taxonomy": {
            "type": "object",
            "properties": {
              "concepts": {"type": "array", "items": {"type": "string"}},
              "skills": {"type": "array", "items": {"type": "string"}},
              "difficulty": {"type": "string", "enum": ["E", "M", "H"]}
            }
          },
          "steps": {
            "type": "array",
            "items": {
              "type": "object",
              "required": ["id", "type", "prompt", "options"],
              "properties": {
                "id": {"type": "string"},
                "type": {
                  "type": "string",
                  "enum": ["read", "extract", "question", "relation", "plan", "compute", "check"]
                },
                "prompt": {"type": "string"},
                "options": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["id", "text", "correct"],
                    "properties": {
                      "id": {"type": "string"},
                      "text": {"type": "string"},
                      "correct": {"type": "boolean"},
                      "distractorType": {"type": "string"},
                      "feedback": {"type": "string"},
                      "nextStep": {"type": "string"}
                    }
                  }
                },
                "multipleSelect": {"type": "boolean"},
                "hints": {"type": "array", "items": {"type": "string"}},
                "validation": {
                  "type": "object",
                  "properties": {
                    "unit": {"type": "string"},
                    "mustUseConditions": {"type": "array", "items": {"type": "string"}}
                  }
                },
                "telemetryKeys": {"type": "array", "items": {"type": "string"}}
              }
            }
          },
          "scoring": {
            "type": "object",
            "properties": {
              "total": {"type": "number"},
              "perStep": {
                "type": "object",
                "additionalProperties": {
                  "type": "object",
                  "properties": {
                    "score": {"type": "number"},
                    "penaltyPerRetry": {"type": "number"},
                    "minScore": {"type": "number"},
                    "timeBonus": {"type": "number"}
                  }
                }
              }
            }
          },
          "transitions": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "fromStep": {"type": "string"},
                "onWrong": {"type": "string"},
                "onCorrect": {"type": "string"},
                "maxRetries": {"type": "integer"}
              }
            }
          },
          "answer": {
            "type": "object",
            "properties": {
              "final": {"type": "string"},
              "unit": {"type": "string"},
              "rationale": {"type": "string"}
            }
          }
        }
      }
    }
  }
}
分步引导的状态机设计
步骤类型与目标对齐
读题 read: 识别主体、单位、数字范围，建立语境。

产出: 题目类型/场景判断（单价问题、差倍、速时路）。

抽条件 extract: 分类直接条件与间接/隐含条件。

产出: 条件清单（选择题形式：哪些属于直接条件）。

明确问题 question: 确认“求什么、单位”。

产出: 目标对象与单位锁定。

建立关系 relation: 选择正确的数量关系或图示映射。

产出: 关系式雏形或图示选择（如条形图版本A/B）。

制定计划 plan: 决定先后顺序与所需中间量。

产出: 步骤链（1→2→3），每步用到哪些条件。

执行运算 compute: 关键运算节点（每次只做一个核心运算）。

产出: 中间数值或公式选择。

检查校验 check: 单位、数量级、条件使用完整性、逆向验证。

产出: 合理性判断选项。

选项与干扰项策略
正确项设计: 只对齐一个明确子目标，避免“一步两算”。

干扰项类型:

单位误配型: 正确数值+错误单位。

关系误读型: “多一半”与“多一倍”错置。

运算次序型: 应先求中间量却直接合并。

边界估计型: 数量级明显偏大/偏小。

反馈绑定: 每种干扰项附“定制化短反馈+对策提示”。

路由与重试
正确路由: 进入下一步或跳过冗余步（自适应加速）。

错误路由: 给一级提示→再错给二级提示→再错进入“微讲解卡片”→回到同一步。

最大重试: 每步建议 2–3 次，之后提供“看示例→继续”。

计分、适应性与掌握度
计分模型
步级计分: 每步基础分 + 重试惩罚（如每次 -20%），不低于 minScore。

时间加成: 在合理时限内加小额奖励，防止拖沓。

题级加权: 关键步骤（relation、plan、check）权重略高于 compute。

自适应策略
加速通过: 连续正确则省略低层次步（read/extract），直达 relation/plan。

精准补救: 某干扰项被选择→自动追加“同型迷你题”或“微讲解”。

掌握度记录: 按概念与技能维度打点，如“倍数关系识别”“单位一致性”。

出题与生产工作流
从原题到可执行 Item 的五步法
题型分类与意图标注

标签: 概念（如“倍数、条形图、平均”）、技能（“条件分类、关系建模”）。

变量化题干

动作: 把固定数字替换为变量，设置范围与约束（保证整除/合理量级）。

分步拆解与关键错误映射

动作: 对每步列正确子结论，并为每个常错点设计干扰项与针对性反馈。

路由图与重试策略

动作: 为每步定义 onCorrect/onWrong 与提示层级、最大重试次数。

验证与试运行

动作: 校验单位、变量边界、算式合法性；抽样生成若干实例做自动回归测试。

可复用分步模板（按题型）
差倍问题（条形图）

Step 序列: read → extract → question → relation(选条形图) → plan → compute(倍数或差量) → check

关键干扰: “多一半/多一倍”、条形图分段错误。

平均与总量

Step 序列: read → extract → relation(平均三式) → plan → compute → check

关键干扰: 把“总量÷份数”误做“份数÷总量”。

单价—数量—总价

Step 序列: read → extract → relation(三式互推) → plan → compute → check

关键干扰: 单位错配（元/角/分）、合并跨类量。

速时路

Step 序列: read → extract → relation(路=速×时) → plan(分段/统一单位) → compute → check

关键干扰: 小时与分钟换算遗漏、分段路线相加错误。

导入导出与版本管理
文件组织: 一个 ProblemSet 一个 JSON；大项目可按学段/概念拆分多文件。

ID 规范: problemSet.id、item.id、step.id 全局唯一（建议短 UUID）。

版本字段: problemSet.version 与 item 的 semver；重大改动升级主版本。

本地化: locale=zh-CN，文本与单位在同一版本内保持一致；如多语，用 i18n map。

校验: 通过 JSON Schema 自动校验；构建环节做变量约束与可解性检查。

安全备份: 生成 SHA-256 摘要写入 metadata 以追踪变更。

数据与教学分析
核心埋点:

每步: 用时、重试次数、选项 ID、提示层级、路径。

题级: 完成时长、得分、跳过/放弃。

指标看板:

准确率分解: 按概念/技能/干扰类型。

稳定错误: 高频干扰项 TopN → 反向优化题干/提示。

学习曲线: 掌握度随时间的变化（如“单位一致性”从 0.4→0.75）。

示例 Item（含分步与路由）
以“钢笔24支，圆珠笔比钢笔多一半，两种笔共多少支？”为例。

json
{
  "id": "pset-prim-ops-001",
  "version": "1.0.0",
  "locale": "zh-CN",
  "metadata": {
    "gradeBand": "G3-G4",
    "subject": "Math",
    "tags": ["差倍", "条形图", "两步运算"],
    "createdAt": "2025-09-16T15:30:00Z",
    "author": "w"
  },
  "items": [
    {
      "id": "item-0001",
      "stem": {
        "text": "文具店有钢笔${a}支，圆珠笔的数量比钢笔多一半。两种笔一共有多少支？",
        "variables": {
          "a": {"type": "int", "range": {"min": 12, "max": 48}, "constraints": ["a % 2 == 0"]}
        }
      },
      "taxonomy": {
        "concepts": ["倍数关系", "总-部分"],
        "skills": ["条件分类", "关系建模", "两步运算"],
        "difficulty": "M"
      },
      "steps": [
        {
          "id": "s1",
          "type": "extract",
          "prompt": "下列哪些属于直接条件？（可多选）",
          "multipleSelect": true,
          "options": [
            {"id": "s1o1", "text": "钢笔有${a}支", "correct": true, "feedback": "直接给出具体数量"},
            {"id": "s1o2", "text": "圆珠笔是钢笔的1.5倍", "correct": false, "distractorType": "inference", "feedback": "这是推理后的等价表述，属于间接条件"},
            {"id": "s1o3", "text": "求两种笔的总数", "correct": false, "distractorType": "goal-vs-condition", "feedback": "这是问题目标，不是条件"}
          ],
          "hints": ["先找题干中的具体数字和单位", "哪些信息无需计算即可使用？"]
        },
        {
          "id": "s2",
          "type": "question",
          "prompt": "本题要求什么？单位是什么？",
          "options": [
            {"id": "s2o1", "text": "圆珠笔的数量，单位：支", "correct": false, "feedback": "这只是中间量"},
            {"id": "s2o2", "text": "两种笔的总数，单位：支", "correct": true, "feedback": "正确：总数与单位匹配"},
            {"id": "s2o3", "text": "钢笔数量，单位：支", "correct": false, "feedback": "已知，不是要求"}
          ]
        },
        {
          "id": "s3",
          "type": "relation",
          "prompt": "以下哪个关系式最合适？",
          "options": [
            {
              "id": "s3o1",
              "text": "圆珠笔 = 钢笔 + 钢笔的一半；总数 = 钢笔 + 圆珠笔",
              "correct": true,
              "feedback": "把“多一半”转为可计算的关系"
            },
            {
              "id": "s3o2",
              "text": "圆珠笔 = 钢笔 × 2；总数 = 钢笔 + 圆珠笔",
              "correct": false,
              "distractorType": "倍数误解",
              "feedback": "把“多一半”误解成“多一倍”"
            },
            {
              "id": "s3o3",
              "text": "总数 = 钢笔 × 圆珠笔",
              "correct": false,
              "distractorType": "结构错误",
              "feedback": "总数是相加关系，不是相乘"
            }
          ],
          "hints": ["“多一半”= 原来再加上一半", "先得到圆珠笔，再求总数"]
        },
        {
          "id": "s4",
          "type": "plan",
          "prompt": "最合理的解题步骤是？",
          "options": [
            {"id": "s4o1", "text": "先求圆珠笔数量，再求两种笔总数", "correct": true, "feedback": "先部分后整体"},
            {"id": "s4o2", "text": "直接把钢笔数量×1.5得到总数", "correct": false, "distractorType": "结构误配", "feedback": "总数需要两种笔相加"}
          ]
        },
        {
          "id": "s5",
          "type": "compute",
          "prompt": "圆珠笔的数量是多少？",
          "options": [
            {"id": "s5o1", "text": "${a} + ${a}/2", "correct": true, "feedback": "等式正确，数值为 ${a + a/2} 支"},
            {"id": "s5o2", "text": "${a} × 2", "correct": false, "distractorType": "倍数误解", "feedback": "这是“多一倍”"},
            {"id": "s5o3", "text": "${a}/2", "correct": false, "distractorType": "漏加原量", "feedback": "忘记加上“原来的”${a}"}
          ],
          "validation": {"unit": "支"}
        },
        {
          "id": "s6",
          "type": "compute",
          "prompt": "两种笔一共有多少支？",
          "options": [
            {"id": "s6o1", "text": "${a} + (${a} + ${a}/2)", "correct": true, "feedback": "合并得到 ${(3*a)/2} 支"},
            {"id": "s6o2", "text": "${a} × 1.5", "correct": false, "distractorType": "漏加另一类", "feedback": "只包含圆珠笔，不包含两类相加"}
          ],
          "validation": {"unit": "支"},
          "hints": ["总数是两类相加"]
        },
        {
          "id": "s7",
          "type": "check",
          "prompt": "以下哪项最能验证结果合理？",
          "options": [
            {"id": "s7o1", "text": "圆珠笔约为钢笔的1.5倍，总数应约为2.5倍的钢笔数", "correct": true, "feedback": "数量级合理"},
            {"id": "s7o2", "text": "总数应小于钢笔数量", "correct": false, "distractorType": "单调性错误", "feedback": "总数必大于任一部分"}
          ]
        }
      ],
      "transitions": [
        {"fromStep": "s1", "onCorrect": "s2", "onWrong": "s1", "maxRetries": 2},
        {"fromStep": "s2", "onCorrect": "s3", "onWrong": "s2", "maxRetries": 2},
        {"fromStep": "s3", "onCorrect": "s4", "onWrong": "s3", "maxRetries": 2},
        {"fromStep": "s4", "onCorrect": "s5", "onWrong": "s4", "maxRetries": 2},
        {"fromStep": "s5", "onCorrect": "s6", "onWrong": "s5", "maxRetries": 2},
        {"fromStep": "s6", "onCorrect": "s7", "onWrong": "s6", "maxRetries": 2},
        {"fromStep": "s7", "onCorrect": "", "onWrong": "s7", "maxRetries": 1}
      ],
      "scoring": {
        "total": 10,
        "perStep": {
          "s1": {"score": 1, "penaltyPerRetry": 0.2, "minScore": 0.2},
          "s2": {"score": 1, "penaltyPerRetry": 0.2, "minScore": 0.2},
          "s3": {"score": 2, "penaltyPerRetry": 0.4, "minScore": 0.4},
          "s4": {"score": 2, "penaltyPerRetry": 0.4, "minScore": 0.4},
          "s5": {"score": 2, "penaltyPerRetry": 0.4, "minScore": 0.4},
          "s6": {"score": 1, "penaltyPerRetry": 0.2, "minScore": 0.2},
          "s7": {"score": 1, "penaltyPerRetry": 0.2, "minScore": 0.2}
        }
      },
      "answer": {
        "final": "(3/2)×${a}",
        "unit": "支",
        "rationale": "由“多一半”得圆珠笔=1.5×钢笔，总数=钢笔+圆珠笔=2.5×钢笔"
      }
    }
  ]
}
说明：变量 a 将在渲染时实例化；可在构建阶段生成多个不同 a 的具体 Item 实例，形成批量题库。

前端流程与交互要点
最少即最强 UI: 每步只显示一件事：题干固定在侧栏，当前步提示在主区。

单位可视化: 在 compute 步“单位栏”常驻提醒，错误时高亮。

提示渐进: 点击“需要提示”才展开，避免打断流。

跳步逻辑: 连续 2 步一拍即合可触发“快速通道”，进入 relation 或 plan。

可视化组件: 条形图/时间轴，作为 relation/plan 的选项之一（可选择“图A/图B”）。

质量保障与边界情况
变量约束: 保证分数/整除（如平均数、半数），避免小数给低年级。

单位统一: 在 schema 校验“步级 unit 一致性”，遇到混合单位必须在 plan 步先换算。

不可解检测: 自动检查 mustUseConditions 是否可在路线中全部覆盖。

干扰项审查: 每个干扰项对应唯一、可命名的错误类型，便于统计与教研复盘。

可访问性: 选项长度控制，避免阅读负担；关键术语支持高亮与术语卡。

如果你愿意，我可以按你打算覆盖的知识图谱（如“差倍、平均、单价数量总价、速时路”）批量产出可直接使用的 JSON 题库雏形，并配套自动化校验脚本的规则清单。告诉我你的年级段与首批题量目标（例如每类各50题），我就给你第一版可导入文件与变量约束。

我应该如何设计用户界面？
好的 w，我们可以把你的数学分步引导系统的 UI 设计 拆成三个层次来考虑：信息结构、交互流程、视觉呈现。目标是让小学生在界面中“看得懂、点得准、走得顺”，同时方便你批量生成和统一格式化题目。

1. 信息结构（Information Architecture）
核心原则
固定区 + 动态区：题干和关键信息固定在一个区域，分步引导内容在另一个区域动态切换。

最少干扰：每一步只呈现一件事，避免信息过载。

可回溯：学生可以回看前一步的提示或自己的选择。

推荐布局
区域	功能	设计要点
左侧/顶部固定栏	题干、插图、变量值	- 题干常驻，变量高亮<br>- 支持简单图示（条形图、表格）<br>- 单位用颜色或图标标识
主交互区	当前步骤的选择题	- 大字号、选项间距大<br>- 每个选项可点击后立即反馈<br>- 支持多选（有明显提示）
辅助区	提示、反馈、进度	- 提示分层展开<br>- 进度条或步骤编号<br>- 错误反馈简短直白
2. 交互流程（Interaction Flow）
分步引导的 UI 节奏
Step Header：显示当前步骤类型（如“提取条件”）+ 简短说明。

Prompt 区：当前问题的文字/图示。

Options 区：选择题选项，点击即判对错。

即时反馈：

正确：绿色勾 + 简短肯定语 + 下一步按钮。

错误：红色叉 + 针对性提示（可展开详细解释）。

进度指示：顶部或侧边显示“第 X 步 / 共 Y 步”。

可选的“回顾”按钮：回看前一步的题干和自己选的答案。

关键交互细节
防误触：选项按钮大、间距足够，适合触屏。

提示渐进：第一次错给轻提示，再错给详细讲解。

单位常驻提醒：在计算步，单位显示在输入框或选项旁。

图文结合：relation/plan 步骤可直接点选图示（如条形图版本A/B）。

3. 视觉呈现（Visual Design）
色彩与层级
主色：温暖明亮（如蓝绿系），降低紧张感。

反馈色：绿色=正确，红色=错误，黄色=提示。

高亮：数字、单位、关键词用背景色或描边突出。

字体与排版
题干：大字号、行距适中，便于低年级阅读。

选项：每个选项独立卡片式，点击范围大。

图示：简洁、色块分明，避免复杂细节。

动画与过渡
轻微过渡：正确/错误反馈用淡入淡出，不要闪烁。

进度变化：进度条平滑增长，给成就感。

4. 针对你系统的特别建议
结合你要批量生成 JSON 题库的需求，UI 还应支持：

动态渲染：从 JSON 自动生成题干、选项、图示。

变量替换高亮：变量值在题干中用特殊样式标出。

多题型兼容：单选、多选、图形选择、填空（可后期扩展）。

教师模式：显示正确答案、干扰项类型、学生作答路径。

5. 示例界面草图（文字描述）
代码
┌───────────────────────────────┐
│ 题干区（固定）                 │
│ 文具店有钢笔 24 支，圆珠笔比... │
│ [条形图示意]                   │
└───────────────────────────────┘

[步骤 2/7] 本题要求什么？单位是什么？
( ) 圆珠笔的数量，单位：支
(●) 两种笔的总数，单位：支
( ) 钢笔数量，单位：支

[正确] ✅ 总数与单位匹配
[下一步 →]

进度条: ███░░░░░░  2/7
如果你愿意，我可以帮你画一个 完整的 UI 流程图，把每个步骤的界面状态、按钮、反馈、路由都标出来，这样你在开发时可以直接交给前端实现。 你是想让我先画 低保真线框图 还是直接给你 高保真配色方案 的版本？

帮我生成一个完整的页面，请调用你的最大算力并结合你的知识库深入详细解析一下
单页原型代码与说明
下面是一个可直接运行的前端单页，包含：固定题干区、分步引导、单选/多选、提示分层、即时反馈、进度条、路由跳转、计分、变量替换与一个示例题目。将代码保存为 html 文件，在浏览器中打开即可体验。

运行说明
使用方式: 将下方代码保存为 math_trainer.html，用浏览器打开。

核心能力: 从内置 JSON 题集加载数据，渲染分步流程，完成选项判断、提示、反馈、进度与得分。

扩展点: 代码内以 TODO 标注的地方可接入你的题库生成与 Schema 校验。

可运行页面代码
html
<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>分步引导数学练习 | 原型</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #f7f9fc;
      --panel: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --primary: #2563eb;
      --primary-weak: #dbeafe;
      --ok: #16a34a;
      --err: #dc2626;
      --warn: #d97706;
      --border: #e5e7eb;
      --chip: #eef2ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans SC", "PingFang SC", "Microsoft YaHei", Arial, sans-serif;
      color: var(--text); background: var(--bg);
    }
    header {
      background: var(--panel); border-bottom: 1px solid var(--border);
      padding: 12px 16px; position: sticky; top: 0; z-index: 10;
      display: flex; gap: 12px; align-items: center; justify-content: space-between;
    }
    header .brand { font-weight: 700; color: var(--primary); }
    header .meta { font-size: 12px; color: var(--muted); }
    main { display: grid; gap: 16px; grid-template-columns: 380px 1fr; padding: 16px; max-width: 1200px; margin: 0 auto; }
    @media (max-width: 960px) { main { grid-template-columns: 1fr; } }
    .panel {
      background: var(--panel); border: 1px solid var(--border); border-radius: 10px; padding: 16px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.03);
    }
    .stem h2 { font-size: 16px; margin: 0 0 8px; color: var(--muted); }
    .stem .text { font-size: 18px; line-height: 1.6; }
    .tags { margin-top: 8px; display: flex; flex-wrap: wrap; gap: 6px; }
    .chip { background: var(--chip); color: #3730a3; border: 1px solid #c7d2fe; padding: 2px 8px; border-radius: 999px; font-size: 12px; }
    .vars { margin-top: 8px; font-size: 14px; color: var(--muted); }
    .progress {
      width: 100%; height: 10px; background: #f1f5f9; border-radius: 999px; overflow: hidden; margin: 10px 0 4px;
    }
    .bar { height: 100%; background: linear-gradient(90deg, var(--primary), #22c55e); width: 0%; transition: width .25s ease; }
    .step-hdr {
      display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;
    }
    .step-type { font-size: 13px; color: var(--muted); }
    .step-idx { font-size: 13px; color: var(--muted); }
    .prompt { font-size: 18px; margin: 8px 0 12px; }
    .options { display: grid; gap: 10px; }
    .opt {
      border: 1px solid var(--border); border-radius: 10px; padding: 12px; background: #fff; cursor: pointer; transition: border .15s, background .15s, transform .05s;
    }
    .opt:hover { border-color: var(--primary); }
    .opt.selected { border-color: var(--primary); background: var(--primary-weak); }
    .opt.correct { border-color: var(--ok); }
    .opt.wrong { border-color: var(--err); }
    .btns { display: flex; gap: 10px; margin-top: 12px; flex-wrap: wrap; }
    button {
      appearance: none; border: 1px solid var(--border); background: #fff; color: var(--text);
      padding: 8px 12px; border-radius: 8px; cursor: pointer; transition: background .15s, transform .05s;
    }
    button.primary { background: var(--primary); border-color: var(--primary); color: #fff; }
    button:active { transform: translateY(1px); }
    .feedback {
      margin-top: 10px; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: #f8fafc; font-size: 14px;
    }
    .feedback.ok { border-color: #bbf7d0; background: #f0fdf4; color: var(--ok); }
    .feedback.err { border-color: #fecaca; background: #fef2f2; color: var(--err); }
    .hint {
      margin-top: 8px; border-left: 3px solid var(--warn); background: #fffbeb; padding: 8px 10px; border-radius: 6px; color: #92400e; font-size: 14px;
    }
    .footer {
      font-size: 12px; color: var(--muted); margin-top: 10px; display: flex; justify-content: space-between; flex-wrap: wrap; gap: 6px;
    }
    .score { font-weight: 700; color: var(--primary); }
    .telemetry { font-size: 12px; color: var(--muted); max-height: 120px; overflow: auto; background: #f8fafc; border: 1px dashed var(--border); padding: 8px; border-radius: 8px; }
    .unit-pill { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #ecfeff; border: 1px solid #a5f3fc; color: #0e7490; font-size: 12px; margin-left: 6px; }
    .legend { font-size: 12px; color: var(--muted); display: flex; gap: 8px; flex-wrap: wrap; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: #f3f4f6; border: 1px solid #e5e7eb; border-bottom-width: 2px; padding: 0 6px; border-radius: 6px; }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <header>
    <div>
      <div class="brand">分步引导数学练习</div>
      <div class="meta">原型版 · 单页应用</div>
    </div>
    <div class="legend">
      <span>正确 <span style="color:var(--ok)">●</span></span>
      <span>错误 <span style="color:var(--err)">●</span></span>
      <span>提示 <span style="color:var(--warn)">●</span></span>
    </div>
  </header>

  <main>
    <aside class="panel stem" id="stemPanel">
      <h2>题目</h2>
      <div class="text" id="stemText"></div>
      <div class="vars" id="varInfo"></div>
      <div class="tags" id="tags"></div>

      <div style="margin-top:12px">
        <div style="font-size:12px;color:var(--muted);margin-bottom:6px;">进度</div>
        <div class="progress"><div class="bar" id="progressBar"></div></div>
        <div class="footer">
          <div id="stepCounter">第 0/0 步</div>
          <div>当前单位 <span class="unit-pill" id="unitPill">—</span></div>
        </div>
      </div>
    </aside>

    <section class="panel" id="workPanel">
      <div class="step-hdr">
        <div class="step-type" id="stepType">—</div>
        <div class="step-idx" id="stepIdx">—</div>
      </div>
      <div class="prompt" id="prompt">—</div>
      <div class="options" id="options"></div>

      <div class="feedback hidden" id="feedbackBox"></div>
      <div class="hint hidden" id="hintBox"></div>

      <div class="btns">
        <button id="showHintBtn">需要提示</button>
        <button class="primary" id="confirmBtn">确认</button>
        <button id="nextBtn" class="hidden">下一步</button>
        <button id="prevBtn">上一步</button>
        <button id="resetBtn">重做本题</button>
      </div>

      <div class="footer">
        <div>分值 <span class="score" id="scoreNow">0</span> / <span id="scoreTotal">0</span></div>
        <div id="timer">⏱️ 0s</div>
      </div>

      <div style="margin-top:10px">
        <div style="font-size:12px;color:var(--muted);margin-bottom:6px;">作答记录</div>
        <div class="telemetry" id="telemetry"></div>
      </div>
    </section>
  </main>

  <script>
    // --- Sample ProblemSet (可替换为你的后端/本地文件载入) ---
    const ProblemSet = {
      id: "pset-prim-ops-001",
      version: "1.0.0",
      locale: "zh-CN",
      metadata: {
        gradeBand: "G3-G4",
        subject: "Math",
        tags: ["差倍", "条形图", "两步运算"],
        createdAt: "2025-09-16T15:30:00Z",
        author: "w"
      },
      items: [
        {
          id: "item-0001",
          stem: {
            text: "文具店有钢笔${a}支，圆珠笔的数量比钢笔多一半。两种笔一共有多少支？",
            variables: { a: { type: "int", range: { min: 12, max: 48 }, constraints: ["a % 2 == 0"] } }
          },
          taxonomy: {
            concepts: ["倍数关系", "总-部分"],
            skills: ["条件分类", "关系建模", "两步运算"],
            difficulty: "M"
          },
          steps: [
            {
              id: "s1",
              type: "extract",
              prompt: "下列哪些属于直接条件？（可多选）",
              multipleSelect: true,
              options: [
                { id: "s1o1", text: "钢笔有${a}支", correct: true, feedback: "直接给出具体数量" },
                { id: "s1o2", text: "圆珠笔是钢笔的1.5倍", correct: false, distractorType: "inference", feedback: "这是推理后的表述，属于间接条件" },
                { id: "s1o3", text: "求两种笔的总数", correct: false, distractorType: "goal-vs-condition", feedback: "这是问题目标，不是条件" }
              ],
              hints: ["先找题干中的具体数字和单位", "哪些信息无需计算即可使用？"]
            },
            {
              id: "s2",
              type: "question",
              prompt: "本题要求什么？单位是什么？",
              options: [
                { id: "s2o1", text: "圆珠笔的数量，单位：支", correct: false, feedback: "这是中间量" },
                { id: "s2o2", text: "两种笔的总数，单位：支", correct: true, feedback: "正确：总数与单位匹配" },
                { id: "s2o3", text: "钢笔数量，单位：支", correct: false, feedback: "已知，不是要求" }
              ]
            },
            {
              id: "s3",
              type: "relation",
              prompt: "以下哪个关系式最合适？",
              options: [
                { id: "s3o1", text: "圆珠笔 = 钢笔 + 钢笔的一半；总数 = 钢笔 + 圆珠笔", correct: true, feedback: "把“多一半”转为可计算的关系" },
                { id: "s3o2", text: "圆珠笔 = 钢笔 × 2；总数 = 钢笔 + 圆珠笔", correct: false, distractorType: "倍数误解", feedback: "把“多一半”误解成“多一倍”" },
                { id: "s3o3", text: "总数 = 钢笔 × 圆珠笔", correct: false, distractorType: "结构错误", feedback: "总数是相加关系，不是相乘" }
              ],
              hints: ["“多一半”= 原来再加上一半", "先得到圆珠笔，再求总数"]
            },
            {
              id: "s4",
              type: "plan",
              prompt: "最合理的解题步骤是？",
              options: [
                { id: "s4o1", text: "先求圆珠笔数量，再求两种笔总数", correct: true, feedback: "先部分后整体" },
                { id: "s4o2", text: "直接把钢笔数量×1.5得到总数", correct: false, distractorType: "结构误配", feedback: "总数需要两类相加" }
              ]
            },
            {
              id: "s5",
              type: "compute",
              prompt: "圆珠笔的数量是多少？",
              options: [
                { id: "s5o1", text: "${a} + ${a}/2", correct: true, feedback: "等式正确，数值为 ${a + a/2} 支" },
                { id: "s5o2", text: "${a} × 2", correct: false, distractorType: "倍数误解", feedback: "这是“多一倍”" },
                { id: "s5o3", text: "${a}/2", correct: false, distractorType: "漏加原量", feedback: "忘记加上“原来的”${a}" }
              ],
              validation: { unit: "支" }
            },
            {
              id: "s6",
              type: "compute",
              prompt: "两种笔一共有多少支？",
              options: [
                { id: "s6o1", text: "${a} + (${a} + ${a}/2)", correct: true, feedback: "合并得到 ${(3*a)/2} 支" },
                { id: "s6o2", text: "${a} × 1.5", correct: false, distractorType: "漏加另一类", feedback: "只包含圆珠笔，不包含两类相加" }
              ],
              validation: { unit: "支" },
              hints: ["总数是两类相加"]
            },
            {
              id: "s7",
              type: "check",
              prompt: "以下哪项最能验证结果合理？",
              options: [
                { id: "s7o1", text: "圆珠笔约为钢笔的1.5倍，总数应约为2.5倍的钢笔数", correct: true, feedback: "数量级合理" },
                { id: "s7o2", text: "总数应小于钢笔数量", correct: false, distractorType: "单调性错误", feedback: "总数必大于任一部分" }
              ]
            }
          ],
          transitions: [
            { fromStep: "s1", onCorrect: "s2", onWrong: "s1", maxRetries: 2 },
            { fromStep: "s2", onCorrect: "s3", onWrong: "s2", maxRetries: 2 },
            { fromStep: "s3", onCorrect: "s4", onWrong: "s3", maxRetries: 2 },
            { fromStep: "s4", onCorrect: "s5", onWrong: "s4", maxRetries: 2 },
            { fromStep: "s5", onCorrect: "s6", onWrong: "s5", maxRetries: 2 },
            { fromStep: "s6", onCorrect: "s7", onWrong: "s6", maxRetries: 2 },
            { fromStep: "s7", onCorrect: "", onWrong: "s7", maxRetries: 1 }
          ],
          scoring: {
            total: 10,
            perStep: {
              s1: { score: 1, penaltyPerRetry: 0.2, minScore: 0.2 },
              s2: { score: 1, penaltyPerRetry: 0.2, minScore: 0.2 },
              s3: { score: 2, penaltyPerRetry: 0.4, minScore: 0.4 },
              s4: { score: 2, penaltyPerRetry: 0.4, minScore: 0.4 },
              s5: { score: 2, penaltyPerRetry: 0.4, minScore: 0.4 },
              s6: { score: 1, penaltyPerRetry: 0.2, minScore: 0.2 },
              s7: { score: 1, penaltyPerRetry: 0.2, minScore: 0.2 }
            }
          },
          answer: { final: "(3/2)×${a}", unit: "支", rationale: "圆珠笔=1.5×钢笔，总数=钢笔+圆珠笔=2.5×钢笔" }
        }
      ]
    };

    // --- Utility: 变量替换（支持简单算式求值展示） ---
    function renderTemplate(t, ctx) {
      if (!t || typeof t !== "string") return t;
      return t.replace(/\$\{([^}]+)\}/g, (_, expr) => {
        try {
          const vars = Object.assign({}, ctx);
          // 安全起见，仅允许变量与基本运算
          // eslint-disable-next-line no-new-func
          const fn = new Function(...Object.keys(vars), `return (${expr});`);
          return fn(...Object.values(vars));
        } catch {
          return `?`;
        }
      });
    }

    // --- 简单随机变量实例化（满足偶数约束） ---
    function instantiateVariables(varSpec) {
      const ctx = {};
      for (const [k, spec] of Object.entries(varSpec || {})) {
        if (spec.type === "int") {
          // 简化：只处理偶数约束
          let v = randInt(spec.range?.min ?? 10, spec.range?.max ?? 50);
          if ((spec.constraints || []).includes("a % 2 == 0")) {
            if (k === "a" && v % 2 !== 0) v += 1;
          }
          ctx[k] = v;
        }
      }
      return ctx;
    }
    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

    // --- 应用状态 ---
    const state = {
      itemIdx: 0,
      stepIdx: 0,
      vars: {},
      retries: {}, // stepId -> count
      score: 0,
      startTime: Date.now(),
      stepStart: Date.now(),
      path: [] // telemetry
    };

    // --- DOM refs ---
    const stemText = document.getElementById("stemText");
    const tags = document.getElementById("tags");
    const varInfo = document.getElementById("varInfo");
    const progressBar = document.getElementById("progressBar");
    const stepCounter = document.getElementById("stepCounter");
    const unitPill = document.getElementById("unitPill");
    const stepTypeEl = document.getElementById("stepType");
    const stepIdxEl = document.getElementById("stepIdx");
    const promptEl = document.getElementById("prompt");
    const optionsEl = document.getElementById("options");
    const feedbackBox = document.getElementById("feedbackBox");
    const hintBox = document.getElementById("hintBox");
    const showHintBtn = document.getElementById("showHintBtn");
    const confirmBtn = document.getElementById("confirmBtn");
    const nextBtn = document.getElementById("nextBtn");
    const prevBtn = document.getElementById("prevBtn");
    const resetBtn = document.getElementById("resetBtn");
    const scoreNow = document.getElementById("scoreNow");
    const scoreTotal = document.getElementById("scoreTotal");
    const telemetry = document.getElementById("telemetry");
    const timer = document.getElementById("timer");

    // --- 初始化 ---
    const item = ProblemSet.items[state.itemIdx];
    state.vars = instantiateVariables(item.stem.variables);
    stemText.innerText = renderTemplate(item.stem.text, state.vars);
    varInfo.innerText = "变量: " + Object.entries(state.vars).map(([k,v])=>`${k}=${v}`).join(", ");
    tags.innerHTML = (ProblemSet.metadata.tags || []).map(t => `<span class="chip">${t}</span>`).join("");
    scoreTotal.innerText = item.scoring?.total ?? 0;
    unitPill.innerText = item.answer?.unit || "—";
    renderStep();

    // --- 渲染当前步骤 ---
    function renderStep() {
      const step = item.steps[state.stepIdx];
      if (!step) { renderDone(); return; }
      const total = item.steps.length;
      stepCounter.innerText = `第 ${state.stepIdx + 1}/${total} 步`;
      stepIdxEl.innerText = `步骤 ${state.stepIdx + 1}`;
      stepTypeEl.innerText = mapType(step.type);
      promptEl.innerText = renderTemplate(step.prompt, state.vars);
      feedbackBox.classList.add("hidden");
      hintBox.classList.add("hidden");
      feedbackBox.innerHTML = "";
      hintBox.innerHTML = "";
      nextBtn.classList.add("hidden");
      confirmBtn.disabled = false;
      showHintBtn.disabled = !step.hints || step.hints.length === 0;

      // 进度条
      progressBar.style.width = `${(state.stepIdx) / total * 100}%`;

      // 选项
      optionsEl.innerHTML = "";
      const ms = !!step.multipleSelect;
      step._selection = new Set();
      step.options.forEach(opt => {
        const el = document.createElement("div");
        el.className = "opt";
        el.setAttribute("data-id", opt.id);
        el.innerText = renderTemplate(opt.text, state.vars);
        el.onclick = () => {
          if (ms) {
            if (el.classList.contains("selected")) {
              el.classList.remove("selected");
              step._selection.delete(opt.id);
            } else {
              el.classList.add("selected");
              step._selection.add(opt.id);
            }
          } else {
            // 单选：互斥
            [...optionsEl.children].forEach(c => c.classList.remove("selected"));
            el.classList.add("selected");
            step._selection = new Set([opt.id]);
          }
        };
        optionsEl.appendChild(el);
      });

      // 备注：重置计时
      state.stepStart = Date.now();
      tickTimer();
    }

    function mapType(t) {
      const m = {
        read: "读题",
        extract: "提取条件",
        question: "明确问题",
        relation: "建立关系",
        plan: "制定计划",
        compute: "执行运算",
        check: "检查校验"
      };
      return m[t] || t;
    }

    // --- 确认作答 ---
    confirmBtn.onclick = () => {
      const step = item.steps[state.stepIdx];
      if (!step) return;
      const sel = [...(step._selection || [])];
      if (sel.length === 0) { toast("请选择一个选项"); return; }

      const correctIds = step.options.filter(o => o.correct).map(o => o.id);
      const isMultiple = !!step.multipleSelect;
      const isCorrect = isMultiple
        ? arraysEqual(new Set(sel), new Set(correctIds))
        : (correctIds.length === 1 && sel[0] === correctIds[0]);

      // 标色
      [...optionsEl.children].forEach(el => {
        const id = el.getAttribute("data-id");
        if (correctIds.includes(id)) el.classList.add("correct");
        if (sel.includes(id) && !correctIds.includes(id)) el.classList.add("wrong");
      });

      // 分数 & 反馈
      const stepId = step.id;
      state.retries[stepId] = state.retries[stepId] || 0;
      const retry = state.retries[stepId];

      const per = item.scoring?.perStep?.[stepId];
      if (per) {
        if (isCorrect) {
          const penalty = Math.min(retry * (per.penaltyPerRetry || 0), 1);
          const gain = Math.max((per.score || 0) * (1 - penalty), per.minScore || 0);
          state.score += gain;
        } else {
          state.retries[stepId] += 1;
        }
      }
      scoreNow.innerText = state.score.toFixed(1);

      // 针对性反馈（合并同类项）
      let fb = "";
      if (!isCorrect) {
        const chosen = step.options.filter(o => sel.includes(o.id));
        fb = chosen.map(o => o.feedback).filter(Boolean).join("；");
      } else {
        // 用正确项的反馈给简要正向强化
        const chosen = step.options.filter(o => sel.includes(o.id));
        fb = chosen.map(o => o.feedback).filter(Boolean)[0] || "做得好！";
      }
      feedbackBox.classList.remove("hidden");
      feedbackBox.classList.toggle("ok", isCorrect);
      feedbackBox.classList.toggle("err", !isCorrect);
      feedbackBox.innerText = fb || (isCorrect ? "正确" : "再想想");

      // 路由决策
      const tr = item.transitions.find(t => t.fromStep === stepId);
      const nextId = isCorrect ? tr?.onCorrect : tr?.onWrong;
      const maxR = tr?.maxRetries ?? 2;
      const elapsed = Math.round((Date.now() - state.stepStart) / 1000);

      // Telemetry
      logTL({
        stepId,
        correct: isCorrect,
        selection: sel,
        retries: retry,
        elapsed
      });

      // 下一步按钮显隐
      confirmBtn.disabled = true;
      nextBtn.classList.remove("hidden");
      nextBtn.onclick = () => {
        if (!tr) advance(1);
        else {
          if (!isCorrect && state.retries[stepId] > maxR) {
            // 超过重试：降级给“微讲解”并前进（或停留，按策略）
            hintBox.classList.remove("hidden");
            hintBox.innerText = "小贴士：把“多一半”先转成‘原量 + 一半’，再求总数。";
            // 这里选择“保留在当前步”便于掌握；也可前进。
            // 为演示，仍然保留在当前步。
          } else {
            if (nextId) gotoStep(nextId);
            else advance(1);
          }
        }
      }
    };

    // --- 提示 ---
    showHintBtn.onclick = () => {
      const step = item.steps[state.stepIdx];
      if (!step || !step.hints || step.hints.length === 0) return;
      hintBox.classList.remove("hidden");
      // 分层提示：按已错次数提升强度
      const retry = state.retries[step.id] || 0;
      const idx = Math.min(retry, step.hints.length - 1);
      hintBox.innerText = "提示：" + step.hints[idx];
    };

    // --- 导航 ---
    prevBtn.onclick = () => advance(-1);
    resetBtn.onclick = () => resetItem();

    function advance(delta) {
      state.stepIdx = Math.max(0, Math.min(item.steps.length, state.stepIdx + delta));
      renderStep();
    }
    function gotoStep(stepId) {
      const idx = item.steps.findIndex(s => s.id === stepId);
      if (idx >= 0) {
        state.stepIdx = idx;
        renderStep();
      }
    }

    function renderDone() {
      promptEl.innerText = "已完成本题！";
      optionsEl.innerHTML = "";
      nextBtn.classList.add("hidden");
      confirmBtn.disabled = true;
      const total = item.steps.length;
      progressBar.style.width = "100%";
      stepCounter.innerText = `第 ${total}/${total} 步`;
      feedbackBox.classList.remove("hidden");
      feedbackBox.classList.add("ok");
      feedbackBox.innerHTML = `本题完成。你的得分：<b>${state.score.toFixed(1)}</b> / ${item.scoring?.total ?? 0}`;
      logTL({ done: true, totalScore: state.score });
    }

    function resetItem() {
      state.stepIdx = 0;
      state.retries = {};
      state.score = 0;
      state.startTime = Date.now();
      state.stepStart = Date.now();
      scoreNow.innerText = "0";
      telemetry.innerHTML = "";
      renderStep();
    }

    function toast(msg) {
      feedbackBox.classList.remove("hidden", "ok"); feedbackBox.classList.add("err");
      feedbackBox.innerText = msg;
    }

    // --- 简易计时器 ---
    function tickTimer() {
      const sec = Math.round((Date.now() - state.startTime) / 1000);
      timer.innerText = `⏱️ ${sec}s`;
      requestAnimationFrame(() => setTimeout(tickTimer, 500));
    }

    function logTL(entry) {
      state.path.push({ t: Date.now(), ...entry });
      telemetry.innerText = JSON.stringify(entry, null, 2) + "\n" + telemetry.innerText;
    }

    // --- 变量渲染：渲染选项中的表达式 ---
    // 已在 renderTemplate 中处理；若有复杂单位/小数保留，可在此扩展格式化器。
  </script>
</body>
</html>
关键设计点与扩展建议
数据驱动渲染: 从 JSON 直接驱动“题干—步骤—选项—路由—计分”，无需改写前端逻辑。

渐进式提示: 以重试次数映射提示强度，让学生“够到但不被喂到”。

单位常驻: unitPill 常驻右上，计算步在 schema 中的 validation.unit 可用于校验与高亮。

结果合理性检查: check 步作为最后的元认知把关，帮助形成“估算—逆推”的习惯。

可无障碍与触屏优化: 大尺寸卡片选项、明确状态色、键盘确认（可加 Enter/Space）与 ARIA 标签。

下一步你可以做的事
接入你的题库: 将 ProblemSet 替换为你的 JSON 文件加载；按 schema 批量生成变量与干扰项。

题型组件化: 为 relation 步加入“条形图方案 A/B”图片选项；为速时路加入“单位换算开关”。

掌握度画像: 将 distractorType 汇总到概念/技能维度，构建学生画像并做自适应路由。

导出作答数据: 将 state.path 与成绩打包为 JSON，供老师查看与训练分析。

今天
怎么分步骤引导一个小学生去？比如先读题目，总结出直接条件，间接条件，然后看看题目要求什么，跟条件什么关系，需不需要多步计算等，请把我的思路扩展详细，请调用你的最大算力并结合你的知识库深入详细解析一下 23:11 o3 小学生数学应用题分步骤思维指南 下面是一套专门面向 7–12 岁孩子的“拆题—联想—计算—反思”完整流程。每一步都配有可直接使用的提问语句、练习方法和常见误区纠正建议，家长或老师可以根据孩子的年龄与能力做取舍。 一、总览：8 步解决框架 步骤 目标 关键词给孩子的自问自答 1. 读题 把题目“听”进脑子 “题目想让我知道什么？” 2. 标记 把信息“贴”到纸上 “哪些数字、单位、关系词最关键？” 3. 分类 区分直接/间接条件 “这条信息能直接算吗？还是要再加工？” 4. 明确求值 把问题“指”出来 “题目最后究竟要哪一个量？” 5. 画图/列表 把关系“看”出来 “用线段图/表格能不能更清楚？” 6. 设计步骤 把思路“写”出来 “先算谁？后算谁？为什么？” 7. 计算与检验 把答案“算”出来 “结果合理吗？跟题目条件矛盾吗？” 8. 反思迁移 把经验“带”走 “下次遇到类似题能直接做哪一步？” 二、逐步拆解与教学要点 1. 读题（信息初识） 慢读两遍，第一遍听故事，第二遍找数字。 朗读时强制停顿：数字前 0.5 秒、问号前 1 秒，让大脑有时间捕捉关键信息。 老师/家长提问： “如果把这题讲给同学听，你会怎么说？” “题里一共出现了几个角色（物品）？” 2. 标记（可视化关键信息） 颜色笔：数字红色，单位蓝色，关系词（比、多、还剩、总共）绿色。 避免一次性画满：按句子画，画完一句停 2 秒回头看。 小学三年级开始引入“底线标记法”——只划一句里最有用的两三个词，防止满篇荧光。 3. 分类（直接条件 vs. 间接条件） 直接条件：拿来就能算（如“有 12 支铅笔”）。 间接条件：要转换或组合才能算（如“比 ×× 多 4 支”）。 教孩子用“能不能马上列算式？”快速判断。 建议使用两栏表：左栏直接，右栏间接；写字的动作能加深记忆。 4. 明确求值（锁定目标量） 鼓励把“问号”用红圈圈起来，并抄一遍问题句。 让孩子说出单位：“答案后面应该写什么字？” 加“假如反了”练习：故意写错目标量，让孩子指出哪里不合理。 5. 画图/列表（搭桥） 低年级：线段图、杯子装水图。 高年级：树状图、二维表。 公式：“关系复杂 → 先画图；数量多 → 先列表”。 训练口号：“看不见就画出来，看不清就排成行”。 6. 设计步骤（计算路线图） 回到图或表，圈出可以先算的局部。 写“①、②、③”序号，空两行再填算式——先写思路后做计算。 教“倒推”法：题目求 A，可由 B 得到；B 可由 C 得到…… 一题多解：引导孩子寻找第二条路线，培养灵活性。 7. 计算与检验 口头预估：四舍五入到整十或整百，先得出“大概值”。 竖式/笔算完成后对比预估，误差>10% 立即复查。 单位检查：结果后必须写单位，否则算错。 逆运算自检：加→减，乘→除，把答案带回题干。 8. 反思迁移 三句话笔记： “这题属于 ×× 类型。” “关键一步是 ××。” “下次我可以直接 ××。” 每周把做过的题目按类型贴墙上小卡片，形成“题型地图”。 和生活联系：找家务场景让孩子应用同样的计算链条。 三、实战示范 题目：学校买来 48 支彩笔，分给三个班，每班分到相同数量，还剩 6 支。每班分到多少支？ 读题： 角色：彩笔、三个班、剩余。 标记： 48 支（总数，蓝） 三个班（数量，红） 还剩 6 支（间接条件，绿） 分类： 直接：48 支、6 支 间接：平均给 3 班 求值：每班 ? 支 画图： ──────────48支────────── |——A——|——B——|——C——|6支| 设计步骤： ① 48 - 6 = 42 （可分配的支数） ② 42 ÷ 3 = 14（每班） 计算与检验： 估算：50 ÷3≈17，大致合理。 逆运算：(14×3)+6 = 48 ✅ 反思： 类型：剩余平均分。 关键：先扣掉剩余再平均。 迁移：蛋糕分配、苹果装袋同理。 四、易错点与纠偏 读题太快：采用“慢读计时”——总句数×3 秒为最低读题时间。 漏抄单位：让孩子在答案旁画一个小盒子，盒子里必须填单位才算完。 直接套公式：先让孩子说“为什么用这个公式”，再动笔。 检查敷衍：写下“检 → 单位、数字、运算符”三字口诀，每算完一题口头复诵。 五、逐月训练计划（示例） 第 1 月： • 每天 2 题，用彩笔标记 + 线段图。 第 2 月： • 引入两步运算题并做“倒推”游戏。 第 3–4 月： • 题型分类墙，周末做汇总卡。 第 5 月： • 自己出题互相交换解。 第 6 月： • 口头生活题（买菜找零、配比饮料）→ 完整 8 步。 六、给家长/老师的提示 “先问不告知”——用提问激活思考，而不是直接给方法。 留“犯错空间”——当孩子答案错误时，先让他自己找错。 强化正反馈——关注孩子遵循步骤的努力，而不仅是结果。 逐步撤离支架——从完全示范→半提示→独立完成。 坚持让孩子“每一步都能说得出口”，既练表达也巩固理解。只要流程形成肌肉记忆，再复杂的应用题都能迎刃而解。这段话要怎么理解？请调用你的最大算力，结合你的知识库深入详细解析一下，最后用中文回复
把“每一步都说得出口、形成肌肉记忆”的深度解读
这句话的核心是：把“解题步骤”从老师的外在流程，转化为孩子头脑里的内在程序；通过“口头化—可视化—实践化—自动化”的闭环，让每一步既能被孩子清楚表达（可验证的理解），又能在不同题目中迅速、稳定、低负担地复用（程序化的熟练）。它不是让孩子背口号，而是把“思考动作”标准化、可观测、可训练，最终内化为稳定的操作习惯。

认知机理：为什么“能说出来”与“肌肉记忆”会有效
可言说=可思考： 生成效应：让孩子把脑中的模糊直觉外化成语言，会显著提升理解与记忆（“自己生成”胜过“被动接收”）。 自解释效应：让孩子解释“为什么这一步必须先做”，能促使他们发现隐含关系与错误假设，形成“因果链”而非“口算链”。

稳态自动化=释放算力： 程序化练习→自动化：固定的“读—析—建—算—检”路线上轨后，工作记忆从“找步骤”转移到“看关系、控误差、做检验”，高级思维空间被释放。 检索练习与多样化迁移：同一套路在多题型、多语境中的反复“检索—调用”，强化了提取线索，避免“只会在熟题里用”。

双编码与元认知： 图词并用：口头句型+线段图/表格，让关系“能看见也能说清”，减少歧义。 过程可视的自监控：把每一步“说出口”就是在做元认知检测：我在干什么？凭什么？是否遗漏？

具体落地：什么叫“每一步都能说得出口”
给孩子一套“分步口头句柄”（用时≤5秒/句），每步只问一个问题，只做一件事。

读题（整体—要素）

句柄：“主角是谁？数字和单位是什么？题目要我求什么？”

合格表现：能不看题复述要素，单位说得对。

标记（关键词—单位）

句柄：“我圈出了三个词，表示关系/变化/比较。”

合格表现：能指认“多、少、合计、还剩、平均、倍”。

分类（直接/间接）

句柄：“这条是直接数，那条要先转化（例如‘多一半’=加上原量的一半）。”

合格表现：能把至少一条话语转成可算的式子雏形。

明确求值（目标—单位）

句柄：“我最后求的是……单位是……只有一个答案/有多个答案。”

合格表现：能规范写出答案句式。

关系建模（图/式）

句柄：“我用线段图表示总—部分/差—倍；把话翻成式。”

合格表现：能画出对齐的条形图或列出等式骨架。

设计步骤（先后—中间量）

句柄：“先算……因为……；再算……得到目标。”

合格表现：能列出①②③的目标链，而不是直接写算式堆砌。

计算执行（单位—估算）

句柄：“单位一致，先粗估……结果应大约……”

合格表现：中间结果有单位，数量级合理。

检查反推（完整—逆运算—条件覆盖）

句柄：“把答案带回题干；每个条件都用到/被解释；换一种方法也能接近。”

合格表现：能说出至少一种“反推或替代表达”的验证。

如何把“流程”练成“肌肉记忆”
固定流程卡+限时口播

做法：每题配一张“8步小卡”，每步孩子用5秒口播句柄，家长/老师只做计时与勾选。

要点：时间短、节奏快，避免冗长“讲理”拖垮专注。

约束引导的分层练习

做法：先做“只读—不算”的信息标注题，再做“只画—不算”的关系题，最后才合成完整题。

要点：拆技能，逐层合成，错误定位更清晰。

多情境同构迁移

做法：同一结构换不同外壳（买文具→分饼干→配饮料），让孩子在“变”里识别“不变”。

要点：每轮至少3种语境，保持结构恒定。

错因标签化与针对纠偏

做法：把错误归入少数标签（单位错、倍数误解、顺序错、漏条件），一错一练微题矫正。

要点：“错因—微题—再测”闭环，不做泛化讲评。

间隔重复与回归测试

做法：本周学的下周再测“同构新题”，月末做“混合检索”。

要点：间隔拉开，防止短期记忆假象。

评估标准：如何判断“说得出口”和“肌肉记忆”达标
口播流畅度（步骤可言说）

指标：8步口播总时长≤60秒；每步无卡壳>90%。

观察：是否需要提示词？是否出现“嗯”“然后就算了”这类空话。

步骤完备率（条件覆盖）

指标：关键条件覆盖率≥95%；无跨类别相加/单位错配。

观察：是否能指出“这条条件目前没用上，合理吗？”

策略一致性（先后合理）

指标：≥80%题目先求中间量的顺序正确；无“直接套乘除”的冲动性解。

观察：能否用“因为—所以”说明步骤顺序。

检验质量（逆推/估算）

指标：≥80%题目能做逆推或数量级估算；估算与实算偏差<20%。

观察：答案后自带单位与一句合理性说明。

迁移表现（同构换皮）

指标：同构新题一次通过率≥70%；错误不集中在同一标签。

观察：是否能主动指出“这题跟上次那题结构一样”。

常见误区与对症修正
把“说得出口”做成“背口号”

症状：机械重复句柄，不会转化题意。

修正：每步必须指认“本题的具体词/图/式”，禁止抽象复述。

把“肌肉记忆”练成“套路僵化”

症状：换语境就不会。

修正：每周安排“同构换皮”与“反例题”（如“多一半”vs“多一倍”）对比练。

过度强调计算，忽视建模与检验

症状：上来就算，单位混乱；不会估算与逆推。

修正：规定“先图/表后算”“无单位不下笔”；检验错扣与讲解时间等权。

教师/家长话多，学生话少

症状：孩子依赖提醒。

修正：计时沉默法：老师只问“下一步是什么？为什么？”其余闭嘴。

可直接用的分步话术与小练包
统一句柄卡（打印发放）

读题：“主角是……，数字与单位有……，问的是……”

分类：“直接是……；需要转化的是……（把……变成……）”

关系：“我画……图/我列：……=……+……；……=……×……”

计划：“先……因为……；再……得到……”

计算：“单位是……；估算大约……”

检查：“把答案带回去：……；每条条件：已用/解释；结果合理因……”

3题同构换皮（示例结构：先扣再均分）

题A（彩笔）：先扣剩余再÷班数。

题B（苹果）：先扣坏果再÷篮数。

题C（糖果）：先扣送人再÷人数。

要求：每题必须口播8句柄≤60秒；画一张线段图；写一句“合理性说明”。

在你的系统中如何落格（数据与交互）
步骤到UI的映射

读/分类/关系/计划/计算/检查各一步对应一道“选择题+口播录制按钮”。

关键采集：

口播时长与卡顿次数：评估“说得出口”。

干扰项标签：定位错因（单位、倍数、顺序、遗漏）。

估算与逆推按钮：是否被使用，结果是否合理。

自适应路由

口播时间长或多次错误→插入“只读不算/只画不算”的微任务。

连续正确→跳过低层步骤，直接做关系/计划，提高心流。

达标判据

通关条件：8步齐备+单位正确+估算/逆推至少一项通过。

毕业标记：同构新题一次通过率≥70%，跨语境保真。

如果你点头，我们可以把这套“句柄卡+同构换皮+错因标签”的训练单元直接转成你的题库 JSON 模板与前端交互规范，从今天起让孩子不止会“做对”，更会“说清、想明白、迁得动”。你想先从哪类结构开工（差倍、平均、单价数量总价、速时路）？我给你一包“10题同构换皮+口播句柄+纠错微题”的首批素材。

举个具体的例子把上面的内容走一遍，请调用你的最大算力，结合你的知识库深入详细解析一下，最后用中文回复
示例全流程演练与可落地设计
先用一道典型“两步运算”应用题把“读—标—分—求—图/表—策—算—检—反思”走完整，再给出在你的系统里如何变成逐步选择题与对应 JSON 片段。最后做一次“同构换皮”迁移，检验是否形成可复用的“肌肉记忆”。

示例题一：差倍与总数（两步运算）
题目：文具店有钢笔24支，圆珠笔的数量比钢笔多一半。两种笔一共有多少支？

1. 读题（两遍慢读）
主语与对象: 钢笔、圆珠笔。

数字与单位: 24（支）。

关系词: “比…多一半”。

求值: 两种笔“总数”，单位“支”。

2. 标记（可视化关键信息）
数字高亮: 24（支）。

关系高亮: 多一半（表示在原有基础上再加一半）。

问题高亮: 一共有多少支（总数）。

3. 分类（直接/间接条件）
直接条件: 钢笔有24支（可直接用）。

间接条件: 圆珠笔比钢笔多一半（需转化为式子：圆珠笔 = 钢笔 + 钢笔的一半）。

4. 明确求值（锁定目标量）
目标量: 两种笔的总数。

单位: 支。

是否唯一: 唯一值。

5. 画图/列表（关系可视化）
条形图草图:

钢笔：|———24———|

圆珠笔：|———24———| + |———12———|（钢笔的一半）

等式骨架:

圆珠笔
=
24
+
1
2
⋅
24
,
总数
=
钢笔
+
圆珠笔
6. 设计步骤（计算路线）
步骤①: 先求圆珠笔数量（由“多一半”转化来）。

步骤②: 再求两种笔总数（部分相加到整体）。

7. 计算与检验（单位与合理性）
圆珠笔：

24
+
1
2
⋅
24
=
24
+
12
=
36
 支
总数：

24
+
36
=
60
 支
估算校验: 圆珠笔应约为钢笔的 
1.5
 倍，
1.5
×
24
=
36
，总数为 
24
+
36
=
60
，数量级合理。

逆推校验: 若总数60，去掉钢笔24，剩36合理；36与24之差为12，确为“多一半”。

8. 反思迁移（结构抽象）
类型抽象: 差倍关系 + 部分汇总。

关键词: “多一半” = 原量 + 原量的一半 = 
1.5
𝑥
。

迁移启发: 同构于“甲比乙多一半/多几分之一”的合并问题，可先求甲的具体量，再求总数。

转为分步选择题：界面话术与干扰项
将上述流程拆为7个可点击的选择步，每步只做一件事，给对应干扰项与反馈。

步骤设计与选项
步骤1 提取条件（多选）

正确项: 钢笔有24支。

干扰项: 圆珠笔是钢笔的1.5倍（属于推理后等价表述，非直接条件）；求总数（这是问题目标）。

即时反馈: 指出“直接 vs 目标 vs 推导”。

步骤2 明确问题（单选）

正确项: 求两种笔的总数（单位：支）。

干扰项: 求圆珠笔数量（只是中间量）。

步骤3 建立关系（单选）

正确项: 圆珠笔 = 钢笔 + 钢笔的一半；总数 = 钢笔 + 圆珠笔。

干扰项: 误把“多一半”当“多一倍”（圆珠笔 = 钢笔×2）；误把总数做乘法。

步骤4 制定计划（单选）

正确项: 先求圆珠笔，再求总数。

干扰项: 直接用钢笔×1.5当总数（漏加另一类）。

步骤5 计算圆珠笔（单选）

正确项: 
24
+
24
/
2
。

干扰项: 
24
×
2
（把“多一半”误作“多一倍”）；
24
/
2
（漏加原量）。

步骤6 计算总数（单选）

正确项: 
24
+
(
24
+
24
/
2
)
。

干扰项: 
24
×
1.5
（只得圆珠笔，不是总数）。

步骤7 合理性检查（单选）

正确项: “圆珠笔≈1.5倍钢笔，总数≈2.5倍钢笔数”。

干扰项: “总数应小于钢笔数”（单调性错误）。

可直接复用的 JSON 片段（与前端原型兼容）
说明：仅展示与本例相关的 item 段，字段与你现有 schema 一致；变量可去掉，固定数值更直观。

json
{
  "id": "item-pen-001",
  "stem": {
    "text": "文具店有钢笔24支，圆珠笔的数量比钢笔多一半。两种笔一共有多少支？"
  },
  "taxonomy": {
    "concepts": ["差倍", "总-部分"],
    "skills": ["条件分类", "关系建模", "两步运算"],
    "difficulty": "M"
  },
  "steps": [
    {
      "id": "s1",
      "type": "extract",
      "prompt": "哪些是直接条件？（可多选）",
      "multipleSelect": true,
      "options": [
        {"id":"s1o1","text":"钢笔有24支","correct":true,"feedback":"直接给出的具体数量"},
        {"id":"s1o2","text":"圆珠笔是钢笔的1.5倍","correct":false,"distractorType":"inference","feedback":"需要推理，属于间接条件"},
        {"id":"s1o3","text":"要求两种笔的总数","correct":false,"distractorType":"goal","feedback":"这是问题目标，不是条件"}
      ],
      "hints":["圈数字和单位；不经计算即可用的是直接条件"]
    },
    {
      "id":"s2",
      "type":"question",
      "prompt":"本题最终求什么？单位是什么？",
      "options":[
        {"id":"s2o1","text":"圆珠笔的数量，单位：支","correct":false,"feedback":"这是中间量"},
        {"id":"s2o2","text":"两种笔的总数，单位：支","correct":true,"feedback":"目标明确且单位正确"},
        {"id":"s2o3","text":"钢笔数量，单位：支","correct":false,"feedback":"已知量，不是要求"}
      ]
    },
    {
      "id":"s3",
      "type":"relation",
      "prompt":"选择合适的数量关系：",
      "options":[
        {"id":"s3o1","text":"圆珠笔=钢笔+钢笔的一半；总数=钢笔+圆珠笔","correct":true,"feedback":"把“多一半”转成可算式"},
        {"id":"s3o2","text":"圆珠笔=钢笔×2；总数=钢笔+圆珠笔","correct":false,"distractorType":"倍数误解","feedback":"把“多一半”理解成“多一倍”"},
        {"id":"s3o3","text":"总数=钢笔×圆珠笔","correct":false,"distractorType":"结构错误","feedback":"总-部分应相加"}
      ],
      "hints":["“多一半”= 原量 + 原量的一半"]
    },
    {
      "id":"s4",
      "type":"plan",
      "prompt":"最合理的解题顺序是？",
      "options":[
        {"id":"s4o1","text":"先求圆珠笔数量，再求总数","correct":true,"feedback":"先部分后整体"},
        {"id":"s4o2","text":"钢笔数量×1.5直接得总数","correct":false,"distractorType":"结构误配","feedback":"漏加另一类"}
      ]
    },
    {
      "id":"s5",
      "type":"compute",
      "prompt":"圆珠笔的数量是？",
      "options":[
        {"id":"s5o1","text":"24 + 24/2","correct":true,"feedback":"=36 支"},
        {"id":"s5o2","text":"24 × 2","correct":false,"distractorType":"倍数误解","feedback":"这是“多一倍”"},
        {"id":"s5o3","text":"24/2","correct":false,"distractorType":"漏加原量","feedback":"忘记加上原量24"}
      ],
      "validation":{"unit":"支"}
    },
    {
      "id":"s6",
      "type":"compute",
      "prompt":"两种笔一共有多少支？",
      "options":[
        {"id":"s6o1","text":"24 + (24 + 24/2)","correct":true,"feedback":"=60 支"},
        {"id":"s6o2","text":"24 × 1.5","correct":false,"distractorType":"漏类","feedback":"只得到圆珠笔，没有加上钢笔"}
      ],
      "validation":{"unit":"支"}
    },
    {
      "id":"s7",
      "type":"check",
      "prompt":"哪种检验最合理？",
      "options":[
        {"id":"s7o1","text":"圆珠笔≈1.5倍钢笔，总数≈2.5倍钢笔数","correct":true,"feedback":"数量级正确"},
        {"id":"s7o2","text":"总数应小于钢笔数","correct":false,"distractorType":"单调性错误","feedback":"总数应大于任一部分"}
      ]
    }
  ],
  "transitions":[
    {"fromStep":"s1","onCorrect":"s2","onWrong":"s1","maxRetries":2},
    {"fromStep":"s2","onCorrect":"s3","onWrong":"s2","maxRetries":2},
    {"fromStep":"s3","onCorrect":"s4","onWrong":"s3","maxRetries":2},
    {"fromStep":"s4","onCorrect":"s5","onWrong":"s4","maxRetries":2},
    {"fromStep":"s5","onCorrect":"s6","onWrong":"s5","maxRetries":2},
    {"fromStep":"s6","onCorrect":"s7","onWrong":"s6","maxRetries":2},
    {"fromStep":"s7","onCorrect":"","onWrong":"s7","maxRetries":1}
  ],
  "scoring":{
    "total":10,
    "perStep":{
      "s1":{"score":1,"penaltyPerRetry":0.2,"minScore":0.2},
      "s2":{"score":1,"penaltyPerRetry":0.2,"minScore":0.2},
      "s3":{"score":2,"penaltyPerRetry":0.4,"minScore":0.4},
      "s4":{"score":2,"penaltyPerRetry":0.4,"minScore":0.4},
      "s5":{"score":2,"penaltyPerRetry":0.4,"minScore":0.4},
      "s6":{"score":1,"penaltyPerRetry":0.2,"minScore":0.2},
      "s7":{"score":1,"penaltyPerRetry":0.2,"minScore":0.2}
    }
  },
  "answer":{"final":"60","unit":"支","rationale":"圆珠笔=1.5×钢笔；总数=钢笔+圆珠笔"}
}
同构换皮：平均分配与先扣再均分（两步运算）
题目：学校买来48支彩笔，分给三个班，每班分到相同数量，还剩6支。每班分到多少支？

1–4 步（读—标—分—求）
对象与单位: 彩笔（支），三个班。

直接条件: 48支、剩6支。

间接条件: “每班相同”→平均分。

目标量: 每班分到多少支（单位：支）。

5–7 步（图—策—算—检）
线段图: |———可分配———|———剩6支———|；可分配=48−6。

路线: 先扣剩余得可分配，再除以班数。

计算:

48
−
6
=
42
,
42
÷
3
=
14
 支
检验: 逆推 
(
14
×
3
)
+
6
=
48
；估算 
48
÷
3
≈
16
，扣掉后14合理。

8 步（反思迁移）
类型: 剩余平均分。

关键词: 先扣不可分部分，再平均；平均三式：
平均
=
总量
份数
。

迁移: 与“坏果先扣再装袋平均”同构。

在系统中关键干扰项
顺序误判: 直接 
48
÷
3
；反馈“忽略剩余，先减后除”。

单位遗漏: 结果不写“支”；反馈“无单位不下笔”。

平均误用: 把“总量÷份数”写成“份数÷总量”；反馈“平均三式对齐”。

易错点对照与当场“纠偏微题”
“多一半/多一倍”混淆

纠偏微题: 甲比乙多一半，若乙为 
𝑥
，甲为多少？（选：
𝑥
+
0.5
𝑥
、
2
𝑥
、
𝑥
−
0.5
𝑥
）

正确项: 
𝑥
+
0.5
𝑥
。

总-部分结构误判为乘法

纠偏微题: “总数等于部分之和还是积？”（选：和/积）

正确项: 和。

平均次序错误（未先处理剩余/不可分量）

纠偏微题: “有剩余还要平均吗？”（选：先扣再均/直接均）

正确项: 先扣再均。

这些微题可在主题错误后自动追加一题，形成“错因→矫正→再测”的闭环。

从课堂到软件：执行要点
每步只做一件事: 读/分/求/图/策/算/检分离，避免“一步两算”。

单位常驻提醒: 计算步界面右上角显示当前单位，未选择/未匹配时给黄框警示。

提示渐进: 第一次错给轻提示；第二次错给示意图/等式；第三次错弹“纠偏微题”。

掌握度打点: 错误选项需绑定错因标签（倍数误解、结构误配、平均误用、单位遗漏），用于教研看板与自适应路由。

如果你希望，我可以按这两类结构（“差倍+总数”“先扣再均分”）各批量生成50题：题干、分步选项、干扰项、反馈、路由与计分全部就绪，并导出为统一 JSON 文件，直接接入你现有前端原型。你想先上哪一类，难度（E/M/H）和年级段设成几何？